---
title: "Prismaì—ì„œ Drizzleë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜"
---
import Steps from "@mdx/Steps.astro";
import Npm from "@mdx/Npm.astro";

## ì‹œì‘í•˜ê¸°

ì´ ê°€ì´ë“œëŠ” ê¸°ë³¸ì ì¸ **Prisma** í”„ë¡œì íŠ¸ë¥¼ **Drizzle ORM**ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•˜ëŠ” ê°„ë‹¨í•œ ì ‘ê·¼ ë°©ë²•ì„ ì œê³µí•©ë‹ˆë‹¤. ì˜ˆì œëŠ” `PostgreSQL`ì— ì´ˆì ì„ ë§ì¶”ê³  ìˆì§€ë§Œ, ë‹¤ë¥¸ ì§€ì› ë°ì´í„°ë² ì´ìŠ¤ì—ì„œë„ í”„ë¡œì„¸ìŠ¤ëŠ” ìœ ì‚¬í•©ë‹ˆë‹¤.

### ë§ˆì´ê·¸ë ˆì´ì…˜ í”„ë¡œì„¸ìŠ¤ ê°œìš”

ì• í”Œë¦¬ì¼€ì´ì…˜ ìœ í˜•ì´ë‚˜ API ë ˆì´ì–´ì— ê´€ê³„ì—†ì´, **Prisma**ì—ì„œ **Drizzle ORM**ìœ¼ë¡œ ì „í™˜í•˜ëŠ” ë‹¨ê³„ëŠ” ì¼ê´€ë©ë‹ˆë‹¤:

1. **Drizzle ORM** & **Drizzle Kit** ì„¤ì¹˜
2. **Drizzle config** íŒŒì¼ ì„¤ì •
3. ë°ì´í„°ë² ì´ìŠ¤ ì¸íŠ¸ë¡œìŠ¤í™ì…˜
4. **Drizzle ORM**ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì—°ê²°
5. **Prisma** ì¿¼ë¦¬ë¥¼ **Drizzle ORM** ì¿¼ë¦¬ë¡œ ì „í™˜

ì´ëŸ¬í•œ ë‹¨ê³„ëŠ” REST API(ì˜ˆ: Express, Koa ë˜ëŠ” NestJS ì‚¬ìš©)ë¥¼ ê°œë°œí•˜ë“ , ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ì‘ìš©ì„ ìœ„í•´ **Prisma**ë¥¼ í™œìš©í•˜ëŠ” ë‹¤ë¥¸ ìœ í˜•ì˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ê°œë°œí•˜ë“  ì ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.

## Prisma í”„ë¡œì íŠ¸ ê°œìš”

ì´ ê°€ì´ë“œì—ì„œëŠ” `Express`ë¡œ êµ¬ì¶•ëœ REST APIë¥¼ **Drizzle ORM**ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•  ìƒ˜í”Œ í”„ë¡œì íŠ¸ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤. ë„¤ ê°œì˜ ì—”í‹°í‹°ê°€ ìˆìŠµë‹ˆë‹¤:

```prisma  copy filename="prisma/schema.prisma" collapsable
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


model Product {
  id              Int           @id @default(autoincrement())
  name            String
  supplierId      Int
  unitPrice       Decimal       @db.Decimal(10, 4)
  unitsInStock    Int

  supplier        Supplier?     @relation(fields: [supplierId], references: [id])
  orderDetails    OrderDetail[]

  @@map("products")
}

model Supplier {
  id           Int       @id @default(autoincrement())
  companyName  String
  city         String
  country      String

  products     Product[]

  @@map("suppliers")
}

model OrderDetail {
  orderId   Int
  productId Int
  quantity  Int

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  @@id([orderId, productId])
  @@map("order_details")
}

model Order {
  id             Int       @id @default(autoincrement())
  orderDate      DateTime  @db.Date
  shippedDate    DateTime? @db.Date
  shipAddress    String
  shipPostalCode String?
  shipCountry    String

  orderDetails OrderDetail[]

  @@map("orders")
}
```

ëª¨ë¸ì€ ë‹¤ìŒê³¼ ê°™ì€ ê´€ê³„ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤:

1. `Supplier`ì™€ `Product` ê°„ì˜ `ì¼ëŒ€ë‹¤` ê´€ê³„
2. `Order`ì™€ `Product` ê°„ì˜ `ë‹¤ëŒ€ë‹¤` ê´€ê³„

`ë‹¤ëŒ€ë‹¤` ê´€ê³„ë¥¼ ìœ„í•´ ì¡°ì¸ í…Œì´ë¸” `order_details`ë¥¼ ìƒì„±í•˜ë©°, `Order`ì™€ `Product` ì—”í‹°í‹°ëŠ” `OrderDetail` ì—”í‹°í‹°ì™€ `ì¼ëŒ€ë‹¤` ê´€ê³„ë¥¼ ê°€ì§€ê²Œ ë©ë‹ˆë‹¤.

í•´ë‹¹ í…Œì´ë¸”ë“¤ì€ ìƒì„±ëœ Prisma ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ì‚¬ìš©í•˜ì—¬ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.


```sql copy filename="prisma/migrations/20240101200233_init/migration.sql" collapsable
-- CreateTable
CREATE TABLE "products" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "supplierId" INTEGER NOT NULL,
    "unitPrice" DECIMAL(10,4) NOT NULL,
    "unitsInStock" INTEGER NOT NULL,

    CONSTRAINT "products_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "suppliers" (
    "id" SERIAL NOT NULL,
    "companyName" TEXT NOT NULL,
    "city" TEXT NOT NULL,
    "country" TEXT NOT NULL,

    CONSTRAINT "suppliers_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "order_details" (
    "orderId" INTEGER NOT NULL,
    "productId" INTEGER NOT NULL,
    "quantity" INTEGER NOT NULL,

    CONSTRAINT "order_details_pkey" PRIMARY KEY ("orderId","productId")
);

-- CreateTable
CREATE TABLE "orders" (
    "id" SERIAL NOT NULL,
    "orderDate" DATE NOT NULL,
    "shippedDate" DATE,
    "shipAddress" TEXT NOT NULL,
    "shipPostalCode" TEXT,
    "shipCountry" TEXT NOT NULL,

    CONSTRAINT "orders_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "products" ADD CONSTRAINT "products_supplierId_fkey" FOREIGN KEY ("supplierId") REFERENCES "suppliers"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_details" ADD CONSTRAINT "order_details_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_details" ADD CONSTRAINT "order_details_productId_fkey" FOREIGN KEY ("productId") REFERENCES "products"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
```

ì´ ê°€ì´ë“œëŠ” ë‹¤ìŒ íŒŒì¼ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:

```plaintext
ğŸ“¦ <project root>
 â”œ ğŸ“‚ prisma
 â”‚  â”œ ğŸ“‚ migrations
 â”‚  â”‚  â”œ ğŸ“‚ 20240101200233_init
 â”‚  â”‚  â”‚  â”” ğŸ“œ migration.sql
 â”‚  â”‚  â”” ğŸ“œ migration_lock.toml
 â”‚  â”” ğŸ“œ schema.prisma
 â”œ ğŸ“‚ src
 â”‚  â”œ ğŸ“‚ db
 â”‚  â”‚  â”” ğŸ“œ db.ts
 â”‚  â”œ ğŸ“‚ routers
 â”‚  â”‚  â”œ ğŸ“œ order.router.ts
 â”‚  â”‚  â”œ ğŸ“œ product.router.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.router.ts
 â”‚  â”œ ğŸ“‚ controllers
 â”‚  â”‚  â”œ ğŸ“œ order.controller.ts
 â”‚  â”‚  â”œ ğŸ“œ product.controller.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.controller.ts
 â”‚  â”œ ğŸ“œ index.ts
 â”‚  â”” ğŸ“œ server.ts
 â”œ ğŸ“œ package.json
 â”” ğŸ“œ tsconfig.json
```

<Steps>

#### Drizzle ORM & Drizzle Kit ì„¤ì¹˜

ì²« ë²ˆì§¸ ë‹¨ê³„ëŠ” ë“œë¼ì´ë²„ë¡œ ì‚¬ìš©í•  **Drizzle ORM**ê³¼ `pg` íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ë‘ ë²ˆì§¸ ë‹¨ê³„ëŠ” **Drizzle Kit**ê³¼ `pg`ìš© íƒ€ì…ì„ ì„¤ì¹˜í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. [Drizzle Kit](/docs/kit-overview)ì€ ìë™ SQL ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒì„± ë° ë¹ ë¥¸ í”„ë¡œí† íƒ€ì´í•‘ì„ ìœ„í•œ CLI ë„êµ¬ì…ë‹ˆë‹¤. 

<Npm>
drizzle-orm pg
-D drizzle-kit @types/pg
</Npm>

#### Drizzle config íŒŒì¼ ì„¤ì •

**Drizzle config**ëŠ” **Drizzle Kit**ì´ ì‚¬ìš©í•˜ëŠ” ì„¤ì • íŒŒì¼ë¡œ, ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°, ë§ˆì´ê·¸ë ˆì´ì…˜ í´ë” ë° ìŠ¤í‚¤ë§ˆ íŒŒì¼ì— ëŒ€í•œ ëª¨ë“  ì •ë³´ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.

í”„ë¡œì íŠ¸ ë£¨íŠ¸ì— `drizzle.config.ts` íŒŒì¼ì„ ìƒì„±í•˜ê³  ë‹¤ìŒ ë‚´ìš©ì„ ì¶”ê°€í•˜ì„¸ìš”:

```typescript copy filename="drizzle.config.ts"
import 'dotenv/config'; // make sure to install dotenv package
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'postgresql',
  out: './src/drizzle',
  schema: './src/drizzle/schema.ts',
  dbCredentials: {
    host: process.env.DB_HOST!,
    port: Number(process.env.DB_PORT!),
    user: process.env.DB_USERNAME!,
    password: process.env.DB_PASSWORD!,
    database: process.env.DB_NAME!,
  },
  // Print all statements
  verbose: true,
  // Always ask for confirmation
  strict: true,
});
```

#### ë°ì´í„°ë² ì´ìŠ¤ ì¸íŠ¸ë¡œìŠ¤í™ì…˜

**Drizzle Kit**ì€ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì¸íŠ¸ë¡œìŠ¤í™ì…˜í•˜ê³  ìŠ¤í‚¤ë§ˆ íŒŒì¼ì„ ìƒì„±í•˜ëŠ” CLI ëª…ë ¹ì–´ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ìŠ¤í‚¤ë§ˆ íŒŒì¼ì—ëŠ” ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸”, ì»¬ëŸ¼, ê´€ê³„ ë° ì¸ë±ìŠ¤ì— ëŒ€í•œ ëª¨ë“  ì •ë³´ê°€ í¬í•¨ë©ë‹ˆë‹¤.

```bash
npx drizzle-kit introspect
```

ì´ ëª…ë ¹ì–´ëŠ” src/drizzle í´ë”ì— schema.ts íŒŒì¼ê³¼ í•¨ê»˜ ìŠ¤ëƒ…ìƒ· ë° ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ìƒì„±í•©ë‹ˆë‹¤.

```typescript collapsable copy filename="src/drizzle/schema.ts"
import {
  pgTable,
  varchar,
  timestamp,
  text,
  integer,
  serial,
  foreignKey,
  numeric,
  date,
  primaryKey,
} from 'drizzle-orm/pg-core';
import { sql } from 'drizzle-orm';

export const prismaMigrations = pgTable('_prisma_migrations', {
  id: varchar('id', { length: 36 }).primaryKey().notNull(),
  checksum: varchar('checksum', { length: 64 }).notNull(),
  finishedAt: timestamp('finished_at', { withTimezone: true, mode: 'string' }),
  migrationName: varchar('migration_name', { length: 255 }).notNull(),
  logs: text('logs'),
  rolledBackAt: timestamp('rolled_back_at', { withTimezone: true, mode: 'string' }),
  startedAt: timestamp('started_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  appliedStepsCount: integer('applied_steps_count').default(0).notNull(),
});

export const suppliers = pgTable('suppliers', {
  id: serial('id').primaryKey().notNull(),
  companyName: text('companyName').notNull(),
  city: text('city').notNull(),
  country: text('country').notNull(),
});

export const products = pgTable('products', {
  id: serial('id').primaryKey().notNull(),
  name: text('name').notNull(),
  supplierId: integer('supplierId')
    .notNull()
    .references(() => suppliers.id, { onDelete: 'restrict', onUpdate: 'cascade' }),
  unitPrice: numeric('unitPrice', { precision: 10, scale: 4 }).notNull(),
  unitsInStock: integer('unitsInStock').notNull(),
});

export const orders = pgTable('orders', {
  id: serial('id').primaryKey().notNull(),
  orderDate: date('orderDate').notNull(),
  shippedDate: date('shippedDate'),
  shipAddress: text('shipAddress').notNull(),
  shipPostalCode: text('shipPostalCode'),
  shipCountry: text('shipCountry').notNull(),
});

export const orderDetails = pgTable(
  'order_details',
  {
    orderId: integer('orderId')
      .notNull()
      .references(() => orders.id, { onDelete: 'restrict', onUpdate: 'cascade' }),
    productId: integer('productId')
      .notNull()
      .references(() => products.id, { onDelete: 'restrict', onUpdate: 'cascade' }),
    quantity: integer('quantity').notNull(),
  },
  (table) => [
    primaryKey({ columns: [table.orderId, table.productId], name: 'order_details_pkey' })
  ]
);
```

```sql collapsable copy filename="src/drizzle/0000_cool_puff_adder.sql"
CREATE TABLE IF NOT EXISTS "_prisma_migrations" (
	"id" varchar(36) PRIMARY KEY NOT NULL,
	"checksum" varchar(64) NOT NULL,
	"finished_at" timestamp with time zone,
	"migration_name" varchar(255) NOT NULL,
	"logs" text,
	"rolled_back_at" timestamp with time zone,
	"started_at" timestamp with time zone DEFAULT now() NOT NULL,
	"applied_steps_count" integer DEFAULT 0 NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "suppliers" (
	"id" serial PRIMARY KEY NOT NULL,
	"companyName" text NOT NULL,
	"city" text NOT NULL,
	"country" text NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "products" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"supplierId" integer NOT NULL,
	"unitPrice" numeric(10, 4) NOT NULL,
	"unitsInStock" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "orders" (
	"id" serial PRIMARY KEY NOT NULL,
	"orderDate" date NOT NULL,
	"shippedDate" date,
	"shipAddress" text NOT NULL,
	"shipPostalCode" text,
	"shipCountry" text NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "order_details" (
	"orderId" integer NOT NULL,
	"productId" integer NOT NULL,
	"quantity" integer NOT NULL,
	CONSTRAINT order_details_pkey PRIMARY KEY("orderId","productId")
);
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "products" ADD CONSTRAINT "products_supplierId_fkey" FOREIGN KEY ("supplierId") REFERENCES "suppliers"("id") ON DELETE restrict ON UPDATE cascade;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "order_details" ADD CONSTRAINT "order_details_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE restrict ON UPDATE cascade;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "order_details" ADD CONSTRAINT "order_details_productId_fkey" FOREIGN KEY ("productId") REFERENCES "products"("id") ON DELETE restrict ON UPDATE cascade;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
```

ë˜í•œ ê´€ê³„í˜• ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ìŠ¤í‚¤ë§ˆ íŒŒì¼ì„ ê´€ê³„ í…Œì´ë¸”ë¡œ ì—…ë°ì´íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤:

```typescript copy filename="src/drizzle/schema.ts"
// ...other imports
import { relations } from 'drizzle-orm';

// ...other tables
export const suppliersRelations = relations(suppliers, ({ many }) => ({
  products: many(products),
}));

export const productsRelations = relations(products, ({ one, many }) => ({
  supplier: one(suppliers, { fields: [products.supplierId], references: [suppliers.id] }),
  orderDetails: many(orderDetails),
}));

export const ordersRelations = relations(orders, ({ many }) => ({
  orderDetails: many(orderDetails),
}));

export const orderDetailsRelations = relations(orderDetails, ({ one }) => ({
  order: one(orders, { fields: [orderDetails.orderId], references: [orders.id] }),
  product: one(products, { fields: [orderDetails.productId], references: [products.id] }),
}));
```

ì´ì œ ë‹¤ìŒê³¼ ê°™ì€ íŒŒì¼ êµ¬ì¡°ë¥¼ ê°–ê²Œ ë©ë‹ˆë‹¤:

```plaintext
ğŸ“¦ <project root>
 â”œ ğŸ“‚ src
 â”‚  â”œ ğŸ“‚ drizzle
 â”‚  â”‚  â”œ ğŸ“‚ meta
 |  |  |  â”œ ğŸ“œ _journal.json
 â”‚  â”‚  â”‚  â”” ğŸ“œ 0000_snapshot.json
 â”‚  â”‚  â”œ ğŸ“œ 0000_cool_puff_adder.sql
 â”‚  â”‚  â”” ğŸ“œ schema.ts
 â”‚  â”œ ğŸ“‚ routers
 â”‚  â”‚  â”œ ğŸ“œ order.router.ts
 â”‚  â”‚  â”œ ğŸ“œ product.router.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.router.ts
 â”‚  â”œ ğŸ“‚ controllers
 â”‚  â”‚  â”œ ğŸ“œ order.controller.ts
 â”‚  â”‚  â”œ ğŸ“œ product.controller.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.controller.ts
 â”‚  â”œ ğŸ“œ index.ts
 â”‚  â”” ğŸ“œ server.ts
 â”œ ğŸ“œ package.json
 â”œ ğŸ“œ drizzle.config.ts
 â”” ğŸ“œ tsconfig.json
```

#### Drizzle ORMì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì—°ê²°

`src/drizzle` í´ë”ì— `db.ts` íŒŒì¼ì„ ìƒì„±í•˜ê³  ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •ì„ êµ¬ì„±í•˜ì„¸ìš”:

```typescript copy filename="src/drizzle/db.ts"
import { drizzle } from 'drizzle-orm/node-postgres';
import { Client } from 'pg';
import * as schema from './schema';

export const client = new Client({
  host: process.env.DB_HOST!,
  port: Number(process.env.DB_PORT!),
  user: process.env.DB_USERNAME!,
  password: process.env.DB_PASSWORD!,
  database: process.env.DB_NAME!,
});

// { schema } is used for relational queries
export const db = drizzle({ client, schema });
```

```typescript copy filename="src/index.ts"
import 'dotenv/config';
import { client, db } from './drizzle/db';
import { resolve } from 'node:path';
import { migrate } from 'drizzle-orm/node-postgres/migrator';


(async () => {
  await client.connect();

  // This command run all migrations from the migrations folder and apply changes to the database
  await migrate(db, { migrationsFolder: resolve(__dirname, './drizzle') });

  // ... start your application
})();
```

#### Prisma ì¿¼ë¦¬ë¥¼ Drizzle ORM ì¿¼ë¦¬ë¡œ ì „í™˜

ì´ ì„¹ì…˜ì—ì„œëŠ” **Prisma**ì˜ ì—¬ëŸ¬ ì¿¼ë¦¬ë¥¼ **Drizzle ORM**ìœ¼ë¡œ êµì²´í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

##### ì‚½ì… ì¿¼ë¦¬ êµì²´

`suppliers`ì™€ `products` í…Œì´ë¸”ì— ìƒˆ í–‰ì„ ì‚½ì…í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

1. `POST /suppliers`
```typescript copy filename="src/controllers/supplier.controller.ts"
import { prisma } from '../db/db';

await prisma.supplier.createMany({
  data: [
    { companyName: 'TestCompanyName1', city: 'TestCity1', country: 'TestCountry1' },
    { companyName: 'TestCompanyName2', city: 'TestCity2', country: 'TestCountry2' },
  ],
});
```

**Drizzle ORM**ì—ì„œëŠ” ì¿¼ë¦¬ê°€ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤:

```typescript copy filename="src/controllers/supplier.controller.ts"
import { db } from '../drizzle/db';
import { suppliers } from '../drizzle/schema';

await db.insert(suppliers).values([
  {
    companyName: 'TestCompanyName1',
    city: 'TestCity1',
    country: 'TestCountry1',
  },
  {
    companyName: 'TestCompanyName2',
    city: 'TestCity2',
    country: 'TestCountry2',
  },
]);
```

2. `POST /products`

```typescript copy filename="src/controllers/product.controller.ts"
import { prisma } from '../db/db';

await prisma.product.createMany({
  data: [
    { 
      name: 'TestProductName1',
      supplierId: 1,
      unitPrice: 10,
      unitsInStock: 20,
    },
    {
      name: 'TestProductName2',
      supplierId: 1,
      unitPrice: 25,
      unitsInStock: 7,
    },
    {
      name: 'TestProductName3',
      supplierId: 2,
      unitPrice: 50,
      unitsInStock: 17,
    },
    {
      name: 'TestProductName4',
      supplierId: 2,
      unitPrice: 100,
      unitsInStock: 2,
    },
  ],
});
```

**Drizzle ORM**ì—ì„œëŠ” ì¿¼ë¦¬ê°€ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤:

`unitPrice` í•„ë“œì— ì£¼ì˜í•˜ì„¸ìš”. **Prisma**ì—ì„œëŠ” `number` íƒ€ì…ì´ì§€ë§Œ, **Drizzle ORM**ì—ì„œëŠ” `string` íƒ€ì…ì´ë©°, `number` íƒ€ì…ê³¼ ë‹¬ë¦¬ ì†Œìˆ˜ì  ì´í•˜ 16383ìë¦¬ ì´ìƒì„ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```typescript copy filename="src/controllers/product.controller.ts"
await db.insert(products).values([
  {
    name: 'TestProductName1',
    supplierId: 1,
    unitPrice: '10',
    unitsInStock: 20,
  },
  {
    name: 'TestProductName2',
    supplierId: 1,
    unitPrice: '25',
    unitsInStock: 7,
  },
  {
    name: 'TestProductName3',
    supplierId: 2,
    unitPrice: '50',
    unitsInStock: 17,
  },
  {
    name: 'TestProductName4',
    supplierId: 2,
    unitPrice: '100',
    unitsInStock: 2,
  },
]);
```

##### ì¡°íšŒ ì¿¼ë¦¬ êµì²´

ì´ ì„¹ì…˜ì—ì„œëŠ” ë‹¨ì¼ í–‰ ì¡°íšŒ, ë‹¤ì¤‘ í–‰ ì¡°íšŒ, í–‰ ê°œìˆ˜ ì„¸ê¸°, í–‰ í•„í„°ë§, í…Œì´ë¸” ì¡°ì¸ ë° ê²°ê³¼ í˜ì´ì§€ë„¤ì´ì…˜ ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

1. `GET /products/:id`

```typescript copy filename="src/controllers/product.controller.ts"
import { prisma } from '../db/db';

const { id } = req.params;

const response = await prisma.product.findUnique({
  where: { id },
  include: {
    supplier: true,
  },
});
```

**Drizzle ORM**ì—ì„œëŠ” ì¿¼ë¦¬ê°€ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤:

```typescript copy filename="src/controllers/product.controller.ts"
import { eq } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { products, suppliers } from '../drizzle/schema';

const { id } = req.params;

const response = await db
  .select({
    product: products,
    supplier: suppliers,
  })
  .from(products)
  .where(eq(products.id, id))
  .leftJoin(suppliers, eq(suppliers.id, products.supplierId));

// or you can use relational queries
const response = await db.query.products.findFirst({
  where: (products, { eq }) => eq(products.id, id),
  with: {
    supplier: true,
  },
});
```

ë‘ ORM ëª¨ë‘ ì‘ë‹µì´ íƒ€ì… ì•ˆì „í•©ë‹ˆë‹¤.

```typescript
// response type for Drizzle ORM
const response: {
  product: {
    name: string;
    id: number;
    supplierId: number;
    unitPrice: string;
    unitsInStock: number;
  };
  supplier: {
    id: number;
    companyName: string;
    city: string | null;
    country: string;
  } | null;
}[]
```

2. `GET /products`

```typescript copy filename="src/controllers/product.controller.ts"
import { Prisma } from '@prisma/client';
import { prisma } from '../db/db';

const whereOptions: Prisma.ProductWhereInput = {
  name: { contains: 'test', mode: 'insensitive' },
};

const [response, count] = await Promise.all([
  prisma.product.findMany({
    where: whereOptions,
    take: 10,
    skip: 0,
    select: {
      id: true,
      name: true,
      unitPrice: true,
      unitsInStock: true,
    },
  }),
  prisma.product.count({ where: whereOptions }),
]);
```

**Drizzle ORM**ì—ì„œëŠ” ì¿¼ë¦¬ê°€ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤:

```typescript collapsable copy filename="src/controllers/product.controller.ts"
import { ilike, sql } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { products } from '../drizzle/schema';

const whereOptions = ilike(products.name, `%test%`);

const [response, count] = await Promise.all([
  db
    .select({
      id: products.id,
      name: products.name,
      unitPrice: products.unitPrice,
      unitsInStock: products.unitsInStock,
    })
    .from(products)
    .where(whereOptions)
    .offset(0)
    .limit(10),
  db
    .select({ count: sql<number>`cast(count(${products.id}) as integer)` })
    .from(products)
    .where(whereOptions),
]);

// or you can use relational queries
const whereOptions = ilike(products.name, `%test%`);

const [response, count] = await Promise.all([
  db.query.products.findMany({
    where: whereOptions,
    columns: {
      id: true,
      name: true,
      unitPrice: true,
      unitsInStock: true,
    },
    offset: 0,
    limit: 10,
  }),
  db
    .select({ count: sql<number>`cast(count(${products.id}) as integer)` })
    .from(products)
    .where(whereOptions),
]);
```

ë‘ ORM ëª¨ë‘ ì‘ë‹µì´ íƒ€ì… ì•ˆì „í•©ë‹ˆë‹¤.

```typescript
// response type for Drizzle ORM
const response: {
  id: number;
  name: string;
  unitPrice: string;
  unitsInStock: number;
}[]
```

3. `GET /orders/:id`

**Prisma**ì—ì„œ ì§‘ê³„ í•¨ìˆ˜ëŠ” `aggregate` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ë³µì¡í•œ ì¿¼ë¦¬ì˜ ê²½ìš° íƒ€ì… ì•ˆì „í•˜ì§€ ì•Šì€ `$queryRaw` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

`orders` í…Œì´ë¸”ì—ì„œ `id`, `orderDate` ë° `shipCountry` í•„ë“œë¥¼ ì„ íƒí•˜ê³ , `ì§‘ê³„ í•¨ìˆ˜`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì£¼ë¬¸ì˜ `totalPrice` í•©ê³„, ì£¼ë¬¸ ë‚´ ì œí’ˆì˜ `totalQuantity` í•©ê³„ ë° ì£¼ë¬¸ ë‚´ `totalProducts` ê°œìˆ˜ë¥¼ ê³„ì‚°í•˜ë ¤ê³  í•©ë‹ˆë‹¤.

```typescript copy filename="src/controllers/order.controller.ts"
import { prisma } from '../db/db';

const { id } = req.params;

const order = await prisma.order.findFirst({
  where: { id },
  select: {
    id: true,
    orderDate: true,
    shipCountry: true,
  },
});
if (!order) {
  throw new Error('Order not found');
}

const { _count, _sum } = await prisma.orderDetail.aggregate({
  where: { orderId: id },
  _sum: {
    quantity: true,
  },
  _count: {
    orderId: true,
  },
});

const totalPrice: Array<{ totalPrice: number }> = await prisma.$queryRaw<number>`
  SELECT SUM(unitPrice * quantity) as "totalPrice"
  FROM order_details
  WHERE "orderId" = ${id}
`;

const response = {
  ...order,
  totalPrice: totalPrice[0].totalPrice,
  totalQuantity: _sum.quantity,
  totalProducts: _count.orderId,
};
```

**Drizzle ORM**ì—ì„œëŠ” ì¿¼ë¦¬ê°€ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤:

```typescript copy filename="src/controllers/order.controller.ts"
import { eq, sql } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { orders, orderDetails, products } from '../drizzle/schema';

const { id } = req.params;

const response = await db
      .select({
        id: orders.id,
        shipCountry: orders.shipCountry,
        orderDate: orders.orderDate,
        totalPrice: sql<number>`cast(sum(${orderDetails.quantity} * ${products.unitPrice}) as float)`,
        totalQuantity: sql<number>`cast(sum(${orderDetails.quantity}) as int)`,
        totalProducts: sql<number>`cast(count(${orderDetails.productId}) as int)`,
      })
      .from(orders)
      .where(eq(orders.id, id))
      .groupBy(orders.id)
      .leftJoin(orderDetails, eq(orderDetails.orderId, orders.id))
      .leftJoin(products, eq(products.id, orderDetails.productId));
```

**Drizzle ORM**ì—ì„œëŠ” ì§‘ê³„ í•¨ìˆ˜ë„ íƒ€ì… ì•ˆì „í•œ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

```typescript
// response type
const response: {
  id: number;
  shipCountry: string;
  orderDate: string;
  totalPrice: number;
  totalQuantity: number;
  totalProducts: number;
}[]
```

**ì°¸ê³ :** í˜„ì¬ ê´€ê³„í˜• ì¿¼ë¦¬ì—ì„œëŠ” ì§‘ê³„ê°€ ì§€ì›ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ `core queries`ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

##### ì—…ë°ì´íŠ¸ ì¿¼ë¦¬ êµì²´

ì´ ì„¹ì…˜ì—ì„œëŠ” ì—¬ëŸ¬ í–‰ì„ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

1. `PATCH /suppliers/:id`
  
```typescript copy filename="src/controllers/supplier.controller.ts"
import { prisma } from '../db/db';

const { id } = req.params;

const supplier = await prisma.supplier.update({
  where: { id },
  data: { city: 'TestCity1Updated', country: 'TestCountry1Updated' },
});
```

**Drizzle ORM**ì—ì„œëŠ” ì¿¼ë¦¬ê°€ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤:

```typescript copy filename="src/controllers/supplier.controller.ts"
import { eq } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { suppliers } from '../drizzle/schema';

const { id } = req.params;

await db
    .update(suppliers)
    .set({
      city: 'TestCity1Updated',
      country: 'TestCountry1Updated',
    })
    .where(eq(suppliers.id, id));
```

##### ì‚­ì œ ì¿¼ë¦¬ êµì²´

ì´ ì„¹ì…˜ì—ì„œëŠ” íŠ¸ëœì­ì…˜ì„ ì‚¬ìš©í•˜ì—¬ ë‹¨ì¼ í–‰ê³¼ ì—¬ëŸ¬ í–‰ì„ ì‚­ì œí•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

1. `DELETE /orders/:id`

```typescript copy filename="src/controllers/order.controller.ts"
import { prisma } from '../db/db';

const { id } = req.params;

const orderDetailQuery = prisma.orderDetail.deleteMany({
  where: { orderId: id },
});

const orderQuery = prisma.order.deleteMany({
  where: { id },
});

await prisma.$transaction([orderDetailQuery, orderQuery]);
```

**Drizzle ORM**ì—ì„œëŠ” ì¿¼ë¦¬ê°€ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤:

```typescript copy filename="src/controllers/order.controller.ts"
import { eq } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { orderDetails, orders } from '../drizzle/schema';

const { id } = req.params;

try {
  await db.transaction(async (tx) => {
    await tx.delete(orderDetails).where(eq(orderDetails.orderId, id));

    await tx.delete(orders).where(eq(orders.id, id));
  });
} catch (e) {
  console.error(e);
}
```
</Steps>
