---
title: "TypeORMì—ì„œ Drizzleë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜"
description: "TypeORM í”„ë¡œì íŠ¸ë¥¼ Drizzle ORMìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•˜ëŠ” ë‹¨ê³„ë³„ ê°€ì´ë“œ"
---
import Npm from "@mdx/Npm.astro";
import Steps from "@mdx/Steps.astro";

## ì‹œì‘í•˜ê¸°

ì´ ê°€ì´ë“œëŠ” ê¸°ë³¸ì ì¸ **TypeORM** í”„ë¡œì íŠ¸ë¥¼ **Drizzle ORM**ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•˜ëŠ” ê°„ë‹¨í•œ ì ‘ê·¼ ë°©ë²•ì„ ì œê³µí•©ë‹ˆë‹¤. ì˜ˆì œëŠ” `PostgreSQL`ì— ì¤‘ì ì„ ë‘ê³  ìˆì§€ë§Œ, ë‹¤ë¥¸ ì§€ì›ë˜ëŠ” ë°ì´í„°ë² ì´ìŠ¤ë„ ìœ ì‚¬í•œ ê³¼ì •ì„ ë”°ë¦…ë‹ˆë‹¤.

### ë§ˆì´ê·¸ë ˆì´ì…˜ í”„ë¡œì„¸ìŠ¤ ê°œìš”

ì• í”Œë¦¬ì¼€ì´ì…˜ íƒ€ì…ì´ë‚˜ API ë ˆì´ì–´ì™€ ê´€ê³„ì—†ì´, **TypeORM**ì—ì„œ **Drizzle ORM**ìœ¼ë¡œ ì „í™˜í•˜ëŠ” ë‹¨ê³„ëŠ” ì¼ê´€ë©ë‹ˆë‹¤:

1. **Drizzle ORM** & **Drizzle Kit** ì„¤ì¹˜
2. **Drizzle config** íŒŒì¼ ì„¤ì •
3. ë°ì´í„°ë² ì´ìŠ¤ ì¸íŠ¸ë¡œìŠ¤í™ì…˜
4. **Drizzle ORM**ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì—°ê²°
5. **TypeORM** ì¿¼ë¦¬ë¥¼ **Drizzle ORM** ì¿¼ë¦¬ë¡œ ì „í™˜

ì´ëŸ¬í•œ ë‹¨ê³„ëŠ” REST API(ì˜ˆ: Express, Koa ë˜ëŠ” NestJS)ë¥¼ ê°œë°œí•˜ë“ , **TypeORM**ì„ ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ì‘ìš©ì— í™œìš©í•˜ëŠ” ë‹¤ë¥¸ ìœ í˜•ì˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ê°œë°œí•˜ë“  ì ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.

## TypeORM í”„ë¡œì íŠ¸ ê°œìš”

ì´ ê°€ì´ë“œì—ì„œëŠ” **Drizzle ORM**ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•  ìƒ˜í”Œ í”„ë¡œì íŠ¸ë¡œ `Express`ë¡œ êµ¬ì¶•ëœ REST APIë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ë„¤ ê°œì˜ ì—”í‹°í‹°ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤:

```typescript collapsable copy filename="src/entities/supplier.entity.ts"
import { Column, Entity, OneToMany, PrimaryGeneratedColumn } from 'typeorm';
import { Product } from './product.entity';

@Entity({ name: 'suppliers' })
export class Supplier {
  @PrimaryGeneratedColumn('increment')
  public id: number;

  @Column({ type: 'text' })
  public companyName: string;

  @Column({ type: 'text', nullable: true })
  public city: string;

  @Column({ type: 'text' })
  public country: string;

  @OneToMany(() => Product, (product) => product.supplier)
  public products: Product[];
}
```

```typescript collapsable copy filename="src/entities/product.entity.ts"
import { Column, Entity, JoinColumn, ManyToOne, OneToMany, PrimaryGeneratedColumn } from 'typeorm';
import { OrderDetail } from './order-detail.entity';
import { Supplier } from './supplier.entity';

@Entity({ name: 'products' })
export class Product {
  @PrimaryGeneratedColumn('increment')
  public id: number;

  @Column({ type: 'text' })
  public name: string;

  @Column({ type: 'integer' })
  public supplierId: number;

  @Column({ type: 'decimal', precision: 10, scale: 4 })
  public unitPrice: number;

  @Column({ type: 'integer' })
  public unitsInStock: number;

  @OneToMany(() => OrderDetail, (orderDetail) => orderDetail.product)
  public orderDetails: OrderDetail[];

  @ManyToOne(() => Supplier, (supplier) => supplier.products)
  @JoinColumn({ name: 'supplierId', referencedColumnName: 'id' })
  public supplier: Supplier;
}
```

```typescript collapsable copy filename="src/entities/order.entity.ts"
import { Column, Entity, OneToMany, PrimaryGeneratedColumn } from 'typeorm';
import { OrderDetail } from './order-detail.entity';

@Entity({ name: 'orders' })
export class Order {
  @PrimaryGeneratedColumn('increment')
  public id: number;

  @Column({ type: 'date' })
  public orderDate: Date;

  @Column({ type: 'date', nullable: true })
  public shippedDate: Date;

  @Column({ type: 'text' })
  public shipAddress: string;

  @Column({ type: 'text', nullable: true })
  public shipPostalCode: string;

  @Column({ type: 'text' })
  public shipCountry: string;

  @OneToMany(() => OrderDetail, (orderDetail) => orderDetail.order)
  public orderDetails: OrderDetail[];
}
```

```typescript collapsable copy filename="src/entities/order-detail.entity.ts"
import { Column, Entity, JoinColumn, ManyToOne, PrimaryColumn } from 'typeorm';
import { Order } from './order.entity';
import { Product } from './product.entity';

@Entity({ name: 'order_details' })
export class OrderDetail {
  @PrimaryColumn({ type: 'integer' })
  public orderId: number;

  @PrimaryColumn({ type: 'integer' })
  public productId: number;

  @Column({ type: 'integer' })
  public quantity: number;

  @ManyToOne(() => Order, (order) => order.orderDetails)
  @JoinColumn({ name: 'orderId', referencedColumnName: 'id' })
  public order: Order;

  @ManyToOne(() => Product, (product) => product.orderDetails)
  @JoinColumn({ name: 'productId', referencedColumnName: 'id' })
  public product: Product;
}
```

ëª¨ë¸ì€ ë‹¤ìŒê³¼ ê°™ì€ ê´€ê³„ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤:

1. `Supplier`ì™€ `Product` ê°„ì˜ `ì¼ëŒ€ë‹¤` ê´€ê³„
2. `Order`ì™€ `Product` ê°„ì˜ `ë‹¤ëŒ€ë‹¤` ê´€ê³„

`ë‹¤ëŒ€ë‹¤` ê´€ê³„ë¥¼ ìœ„í•´ ì¡°ì¸ í…Œì´ë¸” `order_details`ë¥¼ ìƒì„±í•˜ë¯€ë¡œ, `Order`ì™€ `Product` ì—”í‹°í‹°ëŠ” `OrderDetail` ì—”í‹°í‹°ì™€ `ì¼ëŒ€ë‹¤` ê´€ê³„ë¥¼ ê°€ì§‘ë‹ˆë‹¤.

í•´ë‹¹ í…Œì´ë¸”ë“¤ì€ ìƒì„±ëœ TypeORM ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ì‚¬ìš©í•˜ì—¬ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.

```typescript copy filename="src/db/migrations/1702216840703-init.ts"
import { MigrationInterface, QueryRunner } from "typeorm";

export class Init1702216840703 implements MigrationInterface {
    name = 'Init1702216840703'

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE TABLE "orders" ("id" SERIAL NOT NULL, "orderDate" date NOT NULL, "shippedDate" date, "shipAddress" text NOT NULL, "shipPostalCode" text, "shipCountry" text NOT NULL, CONSTRAINT "PK_710e2d4957aa5878dfe94e4ac2f" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE TABLE "suppliers" ("id" SERIAL NOT NULL, "companyName" text NOT NULL, "city" text, "country" text NOT NULL, CONSTRAINT "PK_b70ac51766a9e3144f778cfe81e" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE TABLE "products" ("id" SERIAL NOT NULL, "name" text NOT NULL, "supplierId" integer NOT NULL, "unitPrice" numeric(10,4) NOT NULL, "unitsInStock" integer NOT NULL, CONSTRAINT "PK_0806c755e0aca124e67c0cf6d7d" PRIMARY KEY ("id"))`);
        await queryRunner.query(`CREATE TABLE "order_details" ("orderId" integer NOT NULL, "productId" integer NOT NULL, "quantity" integer NOT NULL, CONSTRAINT "PK_e08ee153eb9c98ee497c1d1287e" PRIMARY KEY ("orderId", "productId"))`);
        await queryRunner.query(`ALTER TABLE "products" ADD CONSTRAINT "FK_c143cbc0299e1f9220c4b5debd8" FOREIGN KEY ("supplierId") REFERENCES "suppliers"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "order_details" ADD CONSTRAINT "FK_147bc15de4304f89a93c7eee969" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`);
        await queryRunner.query(`ALTER TABLE "order_details" ADD CONSTRAINT "FK_c67ebaba3e5085b6401911acc70" FOREIGN KEY ("productId") REFERENCES "products"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "order_details" DROP CONSTRAINT "FK_c67ebaba3e5085b6401911acc70"`);
        await queryRunner.query(`ALTER TABLE "order_details" DROP CONSTRAINT "FK_147bc15de4304f89a93c7eee969"`);
        await queryRunner.query(`ALTER TABLE "products" DROP CONSTRAINT "FK_c143cbc0299e1f9220c4b5debd8"`);
        await queryRunner.query(`DROP TABLE "order_details"`);
        await queryRunner.query(`DROP TABLE "products"`);
        await queryRunner.query(`DROP TABLE "suppliers"`);
        await queryRunner.query(`DROP TABLE "orders"`);
    }

}
```

ì´ ê°€ì´ë“œëŠ” ë‹¤ìŒ íŒŒì¼ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:

```text
ğŸ“¦ <project root>
 â”œ ğŸ“‚ src
 â”‚  â”œ ğŸ“‚ db
 â”‚  â”‚  â”œ ğŸ“‚ migrations
 â”‚  â”‚  â”‚  â”” ğŸ“œ 1702216840703-init.ts
 â”‚  â”‚  â”” ğŸ“œ typeorm.config.ts
 â”‚  â”œ ğŸ“‚ entities
 â”‚  â”‚  â”œ ğŸ“œ order-detail.entity.ts
 â”‚  â”‚  â”œ ğŸ“œ order.entity.ts
 â”‚  â”‚  â”œ ğŸ“œ product.entity.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.entity.ts
 â”‚  â”œ ğŸ“‚ routers
 â”‚  â”‚  â”œ ğŸ“œ order.router.ts
 â”‚  â”‚  â”œ ğŸ“œ product.router.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.router.ts
 â”‚  â”œ ğŸ“‚ controllers
 â”‚  â”‚  â”œ ğŸ“œ order.controller.ts
 â”‚  â”‚  â”œ ğŸ“œ product.controller.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.controller.ts
 â”‚  â”œ ğŸ“œ index.ts
 â”‚  â”” ğŸ“œ server.ts
 â”œ ğŸ“œ package.json
 â”” ğŸ“œ tsconfig.json
```

<Steps>

#### Drizzle ORM & Drizzle Kit ì„¤ì¹˜

ì²« ë²ˆì§¸ ë‹¨ê³„ëŠ” ë“œë¼ì´ë²„ë¡œ ì‚¬ìš©í•  **Drizzle ORM**ê³¼ `pg` íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ë‘ ë²ˆì§¸ ë‹¨ê³„ëŠ” **Drizzle Kit**ê³¼ `pg`ìš© íƒ€ì…ì„ ì„¤ì¹˜í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. [Drizzle Kit](/docs/kit-overview)ì€ ìë™ SQL ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒì„±ê³¼ ë¹ ë¥¸ í”„ë¡œí† íƒ€ì´í•‘ì„ ìœ„í•œ CLI ë„êµ¬ì…ë‹ˆë‹¤. 

<Npm>
drizzle-orm pg
-D drizzle-kit @types/pg
</Npm>

#### Drizzle config íŒŒì¼ ì„¤ì •

**Drizzle config**ëŠ” **Drizzle Kit**ì—ì„œ ì‚¬ìš©í•˜ëŠ” ì„¤ì • íŒŒì¼ë¡œ, ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°, ë§ˆì´ê·¸ë ˆì´ì…˜ í´ë” ë° ìŠ¤í‚¤ë§ˆ íŒŒì¼ì— ëŒ€í•œ ëª¨ë“  ì •ë³´ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.

í”„ë¡œì íŠ¸ ë£¨íŠ¸ì— `drizzle.config.ts` íŒŒì¼ì„ ìƒì„±í•˜ê³  ë‹¤ìŒ ë‚´ìš©ì„ ì¶”ê°€í•˜ì„¸ìš”:

```typescript copy filename="drizzle.config.ts"
import 'dotenv/config'; // make sure to install dotenv package
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'postgresql',
  out: './src/drizzle',
  schema: './src/drizzle/schema.ts',
  dbCredentials: {
    host: process.env.DB_HOST!,
    port: Number(process.env.DB_PORT!),
    user: process.env.DB_USERNAME!,
    password: process.env.DB_PASSWORD!,
    database: process.env.DB_NAME!,
  },
  // Print all statements
  verbose: true,
  // Always ask for confirmation
  strict: true,
});
```

#### ë°ì´í„°ë² ì´ìŠ¤ ì¸íŠ¸ë¡œìŠ¤í™ì…˜

**Drizzle Kit**ì€ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì¸íŠ¸ë¡œìŠ¤í™íŠ¸í•˜ê³  ìŠ¤í‚¤ë§ˆ íŒŒì¼ì„ ìƒì„±í•˜ëŠ” CLI ëª…ë ¹ì–´ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ìŠ¤í‚¤ë§ˆ íŒŒì¼ì—ëŠ” ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸”, ì»¬ëŸ¼, ê´€ê³„ ë° ì¸ë±ìŠ¤ì— ëŒ€í•œ ëª¨ë“  ì •ë³´ê°€ í¬í•¨ë©ë‹ˆë‹¤.

```bash
npx drizzle-kit introspect
```

ì´ ëª…ë ¹ì–´ëŠ” src/drizzle í´ë”ì— schema.ts íŒŒì¼ê³¼ ìŠ¤ëƒ…ìƒ· ë° ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ìƒì„±í•©ë‹ˆë‹¤.

```typescript collapsable copy filename="src/drizzle/schema.ts" 
import {
  pgTable,
  serial,
  bigint,
  varchar,
  text,
  foreignKey,
  integer,
  numeric,
  date,
  primaryKey,
} from 'drizzle-orm/pg-core';
import { sql } from 'drizzle-orm';

export const migrations = pgTable('migrations', {
  id: serial('id').primaryKey().notNull(),
  // You can use { mode: "bigint" } if numbers are exceeding js number limitations
  timestamp: bigint('timestamp', { mode: 'number' }).notNull(),
  name: varchar('name').notNull(),
});

export const suppliers = pgTable('suppliers', {
  id: serial('id').primaryKey().notNull(),
  companyName: text('companyName').notNull(),
  city: text('city'),
  country: text('country').notNull(),
});

export const products = pgTable('products', {
  id: serial('id').primaryKey().notNull(),
  name: text('name').notNull(),
  supplierId: integer('supplierId')
    .notNull()
    .references(() => suppliers.id),
  unitPrice: numeric('unitPrice', { precision: 10, scale: 4 }).notNull(),
  unitsInStock: integer('unitsInStock').notNull(),
});

export const orders = pgTable('orders', {
  id: serial('id').primaryKey().notNull(),
  orderDate: date('orderDate').notNull(),
  shippedDate: date('shippedDate'),
  shipAddress: text('shipAddress').notNull(),
  shipPostalCode: text('shipPostalCode'),
  shipCountry: text('shipCountry').notNull(),
});

export const orderDetails = pgTable(
  'order_details',
  {
    orderId: integer('orderId')
      .notNull()
      .references(() => orders.id),
    productId: integer('productId')
      .notNull()
      .references(() => products.id),
    quantity: integer('quantity').notNull(),
  },
  (table) => [
    primaryKey({
      columns: [table.orderId, table.productId],
      name: 'PK_e08ee153eb9c98ee497c1d1287e',
    })
  ],
);
```

```sql collapsable copy filename="src/drizzle/0000_lush_lenny_balinger.sql"
-- Current sql file was generated after introspecting the database

CREATE TABLE IF NOT EXISTS "migrations" (
	"id" serial PRIMARY KEY NOT NULL,
	"timestamp" bigint NOT NULL,
	"name" varchar NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "suppliers" (
	"id" serial PRIMARY KEY NOT NULL,
	"companyName" text NOT NULL,
	"city" text,
	"country" text NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "products" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"supplierId" integer NOT NULL,
	"unitPrice" numeric(10, 4) NOT NULL,
	"unitsInStock" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "orders" (
	"id" serial PRIMARY KEY NOT NULL,
	"orderDate" date NOT NULL,
	"shippedDate" date,
	"shipAddress" text NOT NULL,
	"shipPostalCode" text,
	"shipCountry" text NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "order_details" (
	"orderId" integer NOT NULL,
	"productId" integer NOT NULL,
	"quantity" integer NOT NULL,
	CONSTRAINT PK_e08ee153eb9c98ee497c1d1287e PRIMARY KEY("orderId","productId")
);
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "products" ADD CONSTRAINT "FK_c143cbc0299e1f9220c4b5debd8" FOREIGN KEY ("supplierId") REFERENCES "suppliers"("id") ON DELETE no action ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "order_details" ADD CONSTRAINT "FK_147bc15de4304f89a93c7eee969" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE no action ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "order_details" ADD CONSTRAINT "FK_c67ebaba3e5085b6401911acc70" FOREIGN KEY ("productId") REFERENCES "products"("id") ON DELETE no action ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
```

ë˜í•œ ê´€ê³„í˜• ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ìŠ¤í‚¤ë§ˆ íŒŒì¼ì— ê´€ê³„ í…Œì´ë¸”ì„ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤:

```typescript copy filename="src/drizzle/schema.ts"
// ...other imports
import { relations } from 'drizzle-orm';

// ...other tables 
export const suppliersRelations = relations(suppliers, ({ many }) => ({
  products: many(products),
}));

export const productsRelations = relations(products, ({ one, many }) => ({
  supplier: one(suppliers, { fields: [products.supplierId], references: [suppliers.id] }),
  orderDetails: many(orderDetails),
}));

export const ordersRelations = relations(orders, ({ many }) => ({
  orderDetails: many(orderDetails),
}));

export const orderDetailsRelations = relations(orderDetails, ({ one }) => ({
  order: one(orders, { fields: [orderDetails.orderId], references: [orders.id] }),
  product: one(products, { fields: [orderDetails.productId], references: [products.id] }),
}));
```

ì´ì œ ë‹¤ìŒê³¼ ê°™ì€ íŒŒì¼ êµ¬ì¡°ë¥¼ ê°€ì§€ê²Œ ë©ë‹ˆë‹¤:

```text
ğŸ“¦ <project root>
 â”œ ğŸ“‚ src
 â”‚  â”œ ğŸ“‚ drizzle
 â”‚  â”‚  â”œ ğŸ“‚ meta
 |  |  |  â”œ ğŸ“œ _journal.json
 â”‚  â”‚  â”‚  â”” ğŸ“œ 0000_snapshot.json
 â”‚  â”‚  â”œ ğŸ“œ 0000_lush_lenny_balinger.sql
 â”‚  â”‚  â”” ğŸ“œ schema.ts
 â”‚  â”œ ğŸ“‚ routers
 â”‚  â”‚  â”œ ğŸ“œ order.router.ts
 â”‚  â”‚  â”œ ğŸ“œ product.router.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.router.ts
 â”‚  â”œ ğŸ“‚ controllers
 â”‚  â”‚  â”œ ğŸ“œ order.controller.ts
 â”‚  â”‚  â”œ ğŸ“œ product.controller.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.controller.ts
 â”‚  â”œ ğŸ“œ index.ts
 â”‚  â”” ğŸ“œ server.ts
 â”œ ğŸ“œ package.json
 â”œ ğŸ“œ drizzle.config.ts
 â”” ğŸ“œ tsconfig.json
```

#### Drizzle ORMì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì—°ê²°

`src/drizzle` í´ë”ì— `db.ts` íŒŒì¼ì„ ìƒì„±í•˜ê³  ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •ì„ êµ¬ì„±í•˜ì„¸ìš”:

```typescript copy filename="src/drizzle/db.ts"
import { drizzle } from 'drizzle-orm/node-postgres';
import { Client } from 'pg';
import * as schema from './schema';

export const client = new Client({
  host: process.env.DB_HOST!,
  port: Number(process.env.DB_PORT!),
  user: process.env.DB_USERNAME!,
  password: process.env.DB_PASSWORD!,
  database: process.env.DB_NAME!,
});

// { schema } is used for relational queries
export const db = drizzle({ client, schema });
```

```typescript copy filename="src/index.ts"
import 'dotenv/config';
import { client, db } from './drizzle/db';
import { resolve } from 'node:path';
import { migrate } from 'drizzle-orm/node-postgres/migrator';


(async () => {
  await client.connect();

  // This command run all migrations from the migrations folder and apply changes to the database
  await migrate(db, { migrationsFolder: resolve(__dirname, './drizzle') });

  // ... start your application
})();
```

#### TypeORM ì¿¼ë¦¬ë¥¼ Drizzle ORM ì¿¼ë¦¬ë¡œ ì „í™˜

ì´ ì„¹ì…˜ì—ì„œëŠ” **TypeORM**ì˜ ì—¬ëŸ¬ ì¿¼ë¦¬ë¥¼ **Drizzle ORM**ìœ¼ë¡œ êµì²´í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

##### ì‚½ì… ì¿¼ë¦¬ êµì²´

`suppliers`ì™€ `products` í…Œì´ë¸”ì— ìƒˆ í–‰ì„ ì‚½ì…í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

1. `POST /suppliers`
```typescript copy filename="src/controllers/supplier.controller.ts"
import dataSource from '../db/typeorm.config';
import { Supplier } from '../entities/supplier.entity';

const repository = dataSource.getRepository(Supplier);

const suppliers = repository.create([
  {
    companyName: 'TestCompanyName1',
    city: 'TestCity1',
    country: 'TestCountry1',
  },
  {
    companyName: 'TestCompanyName2',
    city: 'TestCity2',
    country: 'TestCountry2',
  },
]);

await repository.save(suppliers);
```

**Drizzle ORM**ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì¿¼ë¦¬ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤:

```typescript copy filename="src/controllers/supplier.controller.ts"
import { db } from '../drizzle/db';
import { suppliers } from '../drizzle/schema';

await db.insert(suppliers).values([
  {
    companyName: 'TestCompanyName1',
    city: 'TestCity1',
    country: 'TestCountry1',
  },
  {
    companyName: 'TestCompanyName2',
    city: 'TestCity2',
    country: 'TestCountry2',
  },
]);
```

2. `POST /products`

```typescript copy filename="src/controllers/product.controller.ts"
import dataSource from '../db/typeorm.config';
import { Product } from '../entities/product.entity';

const repository = dataSource.getRepository(Product);

const products = repository.create([
  {
    name: 'TestProductName1',
    supplierId: 1,
    unitPrice: 10,
    unitsInStock: 20,
  },
  {
    name: 'TestProductName2',
    supplierId: 1,
    unitPrice: 25,
    unitsInStock: 7,
  },
  {
    name: 'TestProductName3',
    supplierId: 2,
    unitPrice: 50,
    unitsInStock: 17,
  },
  {
    name: 'TestProductName4',
    supplierId: 2,
    unitPrice: 100,
    unitsInStock: 2,
  },
]);

await repository.save(products);
```

**Drizzle ORM**ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì¿¼ë¦¬ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤:

`unitPrice` í•„ë“œì— ì£¼ì˜í•˜ì„¸ìš”. **TypeORM**ì—ì„œëŠ” `number` íƒ€ì…ì´ì§€ë§Œ, **Drizzle ORM**ì—ì„œëŠ” `string` íƒ€ì…ì…ë‹ˆë‹¤. ì´ëŠ” `number` íƒ€ì…ê³¼ ë‹¬ë¦¬ ì†Œìˆ˜ì  ì´í•˜ 16383ìë¦¬ ì´ìƒì„ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```typescript copy filename="src/controllers/product.controller.ts"
await db.insert(products).values([
  {
    name: 'TestProductName1',
    supplierId: 1,
    unitPrice: '10',
    unitsInStock: 20,
  },
  {
    name: 'TestProductName2',
    supplierId: 1,
    unitPrice: '25',
    unitsInStock: 7,
  },
  {
    name: 'TestProductName3',
    supplierId: 2,
    unitPrice: '50',
    unitsInStock: 17,
  },
  {
    name: 'TestProductName4',
    supplierId: 2,
    unitPrice: '100',
    unitsInStock: 2,
  },
]);
```

##### ì¡°íšŒ ì¿¼ë¦¬ êµì²´

ì´ ì„¹ì…˜ì—ì„œëŠ” ë‹¨ì¼ í–‰ ì¡°íšŒ, ì—¬ëŸ¬ í–‰ ì¡°íšŒ, í–‰ ìˆ˜ ì„¸ê¸°, í–‰ í•„í„°ë§, í…Œì´ë¸” ì¡°ì¸ ë° ê²°ê³¼ í˜ì´ì§€ë„¤ì´ì…˜ ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

1. `GET /products/:id`

**TypeORM**ì—ì„œëŠ” ì‘ë‹µ íƒ€ì…ì´ ì—„ê²©í•˜ê²Œ íƒ€ì…ì´ ì§€ì •ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ê´€ê³„ë¥¼ í¬í•¨í•˜ê±°ë‚˜ ëª¨ë“  í•„ë“œ ëŒ€ì‹  ì¼ë¶€ í•„ë“œë§Œ ì„ íƒí•˜ëŠ” ê²½ìš°, ì´ëŸ¬í•œ ìˆ˜ì • ì‚¬í•­ì´ ì‘ë‹µ íƒ€ì…ì— ë°˜ì˜ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```typescript copy filename="src/controllers/product.controller.ts"
import dataSource from '../db/typeorm.config';
import { Product } from '../entities/product.entity';

const { id } = req.params;

const repository = dataSource.getRepository(Product);

const response = await repostitory.findOne({
  where: { id },
  relations: ['supplier'],
});
```

In **Drizzle ORM**, the query is implemented as follows:

```typescript copy filename="src/controllers/product.controller.ts"
import { eq } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { products, suppliers } from '../drizzle/schema';

const { id } = req.params;

const response = await db
  .select({
    product: products,
    supplier: suppliers,
  })
  .from(products)
  .where(eq(products.id, id))
  .leftJoin(suppliers, eq(suppliers.id, products.supplierId));

// or you can use relational queries
const response = await db.query.products.findFirst({
  where: (products, { eq }) => eq(products.id, id),
  with: {
    supplier: true,
  },
});
```

**Drizzle ORM**ì—ì„œëŠ” ì‘ë‹µ íƒ€ì…ì´ select ê°ì²´ì— ì§€ì •ëœ ë‚´ìš©ê³¼ ì •í™•íˆ ì¼ì¹˜í•˜ë¯€ë¡œ, `supplier` ê´€ê³„ë¥¼ í¬í•¨í•˜ëŠ” ê²ƒì´ ì™„ì „íˆ íƒ€ì… ì•ˆì „í•©ë‹ˆë‹¤.

```typescript
// response type
const response: {
  product: {
    name: string;
    id: number;
    supplierId: number;
    unitPrice: string;
    unitsInStock: number;
  };
  supplier: {
    id: number;
    companyName: string;
    city: string | null;
    country: string;
  } | null;
}[]
```

2. `GET /products`

**TypeORM**ì—ì„œëŠ” ì„ íƒí•˜ë ¤ëŠ” í•„ë“œë¥¼ ì§€ì •í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ê²°ê³¼ê°€ íƒ€ì… ì•ˆì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```typescript copy filename="src/controllers/product.controller.ts"
import { ILike } from 'typeorm';
import dataSource from '../db/typeorm.config';
import { Product } from '../entities/product.entity';

const repository = dataSource.getRepository(Product);

const response = await repostitory.findAndCount({
  skip: 0,
  take: 10,
  where: {
    name: ILike(`%test%`),
  },
  select: ['id', 'name', 'unitPrice', 'unitsInStock'],
});
```

In **Drizzle ORM**, the query is implemented as follows:

```typescript collapsable copy filename="src/controllers/product.controller.ts"
import { ilike, sql } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { products } from '../drizzle/schema';

const whereOptions = ilike(products.name, `%test%`);

const [response, count] = await Promise.all([
  db
    .select({
      id: products.id,
      name: products.name,
      unitPrice: products.unitPrice,
      unitsInStock: products.unitsInStock,
    })
    .from(products)
    .where(whereOptions)
    .offset(0)
    .limit(10),
  db
    .select({ count: sql<number>`cast(count(${products.id}) as integer)` })
    .from(products)
    .where(whereOptions),
]);

// or you can use relational queries
const whereOptions = ilike(products.name, `%test%`);

const [response, count] = await Promise.all([
  db.query.products.findMany({
    where: whereOptions,
    columns: {
      id: true,
      name: true,
      unitPrice: true,
      unitsInStock: true,
    },
    offset: 0,
    limit: 10,
  }),
  db
    .select({ count: sql<number>`cast(count(${products.id}) as integer)` })
    .from(products)
    .where(whereOptions),
]);
```

**Drizzle ORM**ì—ì„œëŠ” ê²°ê³¼ê°€ ì—„ê²©í•˜ê²Œ íƒ€ì… ì•ˆì „í•˜ë©°, ì„ íƒí•œ í•„ë“œê°€ ëª…ì‹œì ìœ¼ë¡œ ì •ì˜ë©ë‹ˆë‹¤.

```typescript
// response type
const response: {
  id: number;
  name: string;
  unitPrice: string;
  unitsInStock: number;
}[]
```

3. `GET /orders/:id`

**TypeORM**ì—ì„œëŠ” `findOne` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ê´€ê³„ì™€ í•¨ê»˜ `ì§‘ê³„ í•¨ìˆ˜`ë¥¼ ì‚¬ìš©í•˜ê³  íŠ¹ì • í•„ë“œë¥¼ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ íƒ€ì… ì•ˆì „í•˜ì§€ ì•Šì€ `querybuilder`ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

`orders` í…Œì´ë¸”ì—ì„œ `id`, `orderDate`, `shipCountry` í•„ë“œë¥¼ ì„ íƒí•˜ê³ , `ì§‘ê³„ í•¨ìˆ˜`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì£¼ë¬¸ì˜ `totalPrice` í•©ê³„, ì£¼ë¬¸ ë‚´ ì œí’ˆì˜ `totalQuantity` í•©ê³„, ì£¼ë¬¸ ë‚´ `totalProducts` ê°œìˆ˜ë¥¼ ê³„ì‚°í•˜ë ¤ê³  í•©ë‹ˆë‹¤.

```typescript copy filename="src/controllers/order.controller.ts"
import dataSource from '../db/typeorm.config';
import { Order } from '../entities/order.entity';

const { id } = req.params;

const orderRepository = dataSource.getRepository(Order);

const orderQueryBuilder = orderRepository.createQueryBuilder('order');

const response = await orderQueryBuilder
  .select([
    'order.id as id',
    'order.orderDate as "orderDate"',
    'order.shipCountry as "shipCountry"',
    'SUM(product.unitPrice * detail.quantity)::float as "totalPrice"',
    'SUM(detail.quantity)::int as "totalQuantity"',
    'COUNT(detail.productId)::int as "totalProducts"',
  ])
  .leftJoin('order.orderDetails', 'detail')
  .leftJoin('detail.product', 'product')
  .groupBy('order.id')
  .where('order.id = :id', { id })
  .getRawOne();
```

In **Drizzle ORM**, the query is implemented as follows:

```typescript copy filename="src/controllers/order.controller.ts"
import { eq, sql } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { orders, orderDetails, products } from '../drizzle/schema';

const { id } = req.params;

const response = await db
      .select({
        id: orders.id,
        shipCountry: orders.shipCountry,
        orderDate: orders.orderDate,
        totalPrice: sql<number>`cast(sum(${orderDetails.quantity} * ${products.unitPrice}) as float)`,
        totalQuantity: sql<number>`cast(sum(${orderDetails.quantity}) as int)`,
        totalProducts: sql<number>`cast(count(${orderDetails.productId}) as int)`,
      })
      .from(orders)
      .where(eq(orders.id, id))
      .groupBy(orders.id)
      .leftJoin(orderDetails, eq(orderDetails.orderId, orders.id))
      .leftJoin(products, eq(products.id, orderDetails.productId));
```

**Drizzle ORM**ì—ì„œëŠ” ì§‘ê³„ë¥¼ ì‚¬ìš©í•œ ê²°ê³¼ë„ íƒ€ì… ì•ˆì „í•©ë‹ˆë‹¤.

```typescript
// response type
const response: {
  id: number;
  shipCountry: string;
  orderDate: string;
  totalPrice: number;
  totalQuantity: number;
  totalProducts: number;
}[]
```

**ì°¸ê³ :** í˜„ì¬ ê´€ê³„í˜• ì¿¼ë¦¬ì—ì„œëŠ” ì§‘ê³„ê°€ ì§€ì›ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ `ì½”ì–´ ì¿¼ë¦¬`ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

##### ì—…ë°ì´íŠ¸ ì¿¼ë¦¬ êµì²´

ì´ ì„¹ì…˜ì—ì„œëŠ” ì—¬ëŸ¬ í–‰ì„ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

1. `PATCH /suppliers/:id`

```typescript copy filename="src/controllers/supplier.controller.ts"
import dataSource from '../db/typeorm.config';
import { Supplier } from '../entities/supplier.entity';

const { id } = req.params;

const repository = dataSource.getRepository(Supplier);

const supplier = await repository.findOneBy({ id });
if (!supplier) {
  throw new Error('Supplier not found');
}

supplier.city = 'TestCity1Updated';
supplier.country = 'TestCountry1Updated';

await repository.save(supplier);
```

In **Drizzle ORM**, the query is implemented as follows:

```typescript copy filename="src/controllers/supplier.controller.ts"
import { eq } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { suppliers } from '../drizzle/schema';

const { id } = req.params;

await db
    .update(suppliers)
    .set({
      city: 'TestCity1Updated',
      country: 'TestCountry1Updated',
    })
    .where(eq(suppliers.id, id));
```

##### ì‚­ì œ ì¿¼ë¦¬ êµì²´

ì´ ì„¹ì…˜ì—ì„œëŠ” íŠ¸ëœì­ì…˜ì„ ì‚¬ìš©í•˜ì—¬ ë‹¨ì¼ í–‰ê³¼ ì—¬ëŸ¬ í–‰ì„ ì‚­ì œí•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

1. `DELETE /orders/:id`

```typescript copy filename="src/controllers/order.controller.ts"
import dataSource from '../db/typeorm.config';
import { OrderDetail } from '../entities/order-detail.entity';
import { Order } from '../entities/order.entity';

const { id } = req.params;

const queryRunner = dataSource.createQueryRunner();

await queryRunner.connect();

await queryRunner.startTransaction();

try {
  await queryRunner.manager.delete(OrderDetail, { orderId: id });

  await queryRunner.manager.delete(Order, { id });

  await queryRunner.commitTransaction();
} catch (e) {
  await queryRunner.rollbackTransaction();

  console.error(e);
} finally {
  await queryRunner.release();
}
```

In **Drizzle ORM**, the query is implemented as follows:

```typescript copy filename="src/controllers/order.controller.ts"
import { eq } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { orderDetails, orders } from '../drizzle/schema';

const { id } = req.params;

try {
  await db.transaction(async (tx) => {
    await tx.delete(orderDetails).where(eq(orderDetails.orderId, id));

    await tx.delete(orders).where(eq(orders.id, id));
  });
} catch (e) {
  console.error(e);
}
```

</Steps>
