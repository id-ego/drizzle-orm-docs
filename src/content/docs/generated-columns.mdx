import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Callout from '@mdx/Callout.astro';

# Generated Columns (생성 컬럼)

<Callout type="info">
이 기능을 사용하려면 `drizzle-orm@0.32.0` 이상 및 `drizzle-kit@0.23.0` 이상이 필요합니다
</Callout>

1. Virtual (또는 비영구) Generated Columns: 이 컬럼은 쿼리될 때마다 동적으로 계산됩니다. 데이터베이스에 저장 공간을 차지하지 않습니다.

2. Stored (또는 영구) Generated Columns: 이 컬럼은 행이 삽입되거나 업데이트될 때 계산되며 그 값이 데이터베이스에 저장됩니다. 이를 통해 인덱싱이 가능하며, 각 쿼리마다 값을 다시 계산할 필요가 없어 쿼리 성능을 향상시킬 수 있습니다.

<Callout type="info">
    Generated columns의 구현 및 사용법은 SQL 데이터베이스마다 크게 다를 수 있습니다. PostgreSQL, MySQL, SQLite는 각각 generated columns에 대해 고유한 기능, 가능성 및 제한사항을 가지고 있습니다. 이 섹션에서는 각 데이터베이스 시스템에서 generated columns을 최대한 활용하는 방법을 이해하는 데 도움이 되도록 이러한 차이점을 상세히 살펴보겠습니다.
</Callout>

<Tabs items={["PostgreSQL", "MySQL", "SQLite", "SingleStore (작업 중)", "MSSQL", "CockroachDB"]}>
  <Tab>
    #### 데이터베이스 측
    **타입**: `STORED` 전용

    **작동 방식**
    - 삽입 또는 업데이트 시 다른 컬럼을 기반으로 값을 자동으로 계산합니다.

    **기능**
    - 복잡한 표현식을 미리 계산하여 데이터 접근을 단순화합니다.
    - Generated columns에 대한 인덱스 지원으로 쿼리 성능을 향상시킵니다.

    **제한사항**
    - 기본값을 지정할 수 없습니다.
    - 표현식은 다른 generated columns을 참조하거나 서브쿼리를 포함할 수 없습니다.
    - Generated column 표현식을 수정하려면 스키마 변경이 필요합니다.
    - 기본 키, 외래 키 또는 유니크 제약조건에서 직접 사용할 수 없습니다

    자세한 정보는 [PostgreSQL](https://www.postgresql.org/docs/current/ddl-generated-columns.html) 문서를 확인하세요

    #### Drizzle 측
    Drizzle에서는 모든 컬럼 타입에 `.generatedAlwaysAs()` 함수를 지정하고 지원되는 SQL 쿼리를 추가하여
    이 컬럼 데이터를 자동으로 생성할 수 있습니다.

    #### 기능
    이 함수는 2가지 방법으로 generated 표현식을 받을 수 있습니다:

    <Callout type='warning' collapsed="1.0.0-beta.12 버전부터 변경된 사항">

    이전 버전에서는 `.generatedAlwaysAs()`가 리터럴을 표현식으로 받을 수 있었습니다.

    **`string`**
    <CodeTab>
    ```ts
    export const test = pgTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(`'hello world!'`),
    });
    ```
    ```sql
    CREATE TABLE "test" (
	    "gen_name" text GENERATED ALWAYS AS ('hello world!') STORED
    );
    ```
    </CodeTab>

    </Callout>

    **`sql`** 태그 - Drizzle이 일부 값을 이스케이프하도록 하려는 경우

    <CodeTab>
    ```ts
    export const test = pgTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(sql`'hello "world"!'`),
    });
    ```
    ```sql
    CREATE TABLE "test" (
	    "gen_name" text GENERATED ALWAYS AS ('hello "world"!') STORED
    );
    ```
    </CodeTab>

    **`callback`** - 테이블의 컬럼을 참조해야 하는 경우
    <CodeTab>
    ```ts
    export const test = pgTable("test", {
        name: text("first_name"),
        generatedName: text("gen_name").generatedAlwaysAs(
          (): SQL => sql`'hi, ' || ${test.name} || '!'`
        ),
    });
    ```
    ```sql
    CREATE TABLE "test" (
	    "first_name" text,
	    "gen_name" text GENERATED ALWAYS AS ('hi, ' || "test"."first_name" || '!') STORED
    );
    ```
    </CodeTab>

    **예제** 전체 텍스트 검색을 사용하는 generated columns
   <CodeTabs items={["schema.ts"]}>
	<CodeTab>
	```typescript copy {17-19}
    import { SQL, sql } from "drizzle-orm";
    import { customType, index, integer, pgTable, text } from "drizzle-orm/pg-core";

    const tsVector = customType<{ data: string }>({
      dataType() {
        return "tsvector";
      },
    });

    export const test = pgTable(
      "test",
      {
        id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
        content: text("content"),
        contentSearch: tsVector("content_search", {
          dimensions: 3,
        }).generatedAlwaysAs(
          (): SQL => sql`to_tsvector('english', ${test.content})`
        ),
      },
      (t) => [
        index("idx_content_search").using("gin", t.contentSearch)
      ]
    );
    ```
    ```sql {4}
    CREATE TABLE "test" (
    	"id" integer PRIMARY KEY GENERATED ALWAYS AS IDENTITY (sequence name "test_id_seq" INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START WITH 1 CACHE 1),
    	"content" text,
    	"content_search" "tsvector" GENERATED ALWAYS AS (to_tsvector('english', "test"."content")) STORED
    );
    --> statement-breakpoint
    CREATE INDEX "idx_content_search" ON "test" USING gin ("content_search");
    ```
    </CodeTab>
   </CodeTabs>
  </Tab>
  <Tab>
    #### 데이터베이스 측
    **타입**: `STORED`, `VIRTUAL`

    **작동 방식**
    - 테이블 스키마에서 표현식으로 정의됩니다.
    - Virtual columns은 읽기 작업 중에 계산됩니다.
    - Stored columns은 쓰기 작업 중에 계산되고 저장됩니다.

    **기능**
    - SELECT, INSERT, UPDATE, DELETE 문에서 사용됩니다.
    - Virtual과 stored 모두 인덱싱할 수 있습니다.
    - NOT NULL 및 기타 제약조건을 지정할 수 있습니다.

    **제한사항**
    - Generated column의 값을 직접 삽입하거나 업데이트할 수 없습니다

    자세한 정보는 [MySQL Alter Generated](https://dev.mysql.com/doc/refman/8.4/en/alter-table-generated-columns.html) 문서 및 [MySQL create generated](https://dev.mysql.com/doc/refman/8.4/en/create-table-generated-columns.html) 문서를 확인하세요

    #### Drizzle 측
    Drizzle에서는 모든 컬럼 타입에 `.generatedAlwaysAs()` 함수를 지정하고 지원되는 SQL 쿼리를 추가하여
    이 컬럼 데이터를 자동으로 생성할 수 있습니다.

    #### 기능
    이 함수는 2가지 방법으로 generated 표현식을 받을 수 있습니다:

    <Callout type='warning' collapsed="1.0.0-beta.12 버전부터 변경된 사항">

    이전 버전에서는 `.generatedAlwaysAs()`가 리터럴을 표현식으로 받을 수 있었습니다.

    **`string`**
    <CodeTab>
    ```ts
    export const test = mysqlTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(`'hello world!'`),
    });
    ```

    ```sql
    CREATE TABLE "test" (
	    "gen_name" text GENERATED ALWAYS AS ('hello world!') VIRTUAL
    );
    ```
    </CodeTab>

    </Callout>

    **`sql`** 태그 - Drizzle이 일부 값을 이스케이프하도록 하려는 경우

    <CodeTab>
    ```ts
    export const test = mysqlTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(sql`'hello "world"!'`),
    });
    ```
    ```sql
    CREATE TABLE `test` (
	    `gen_name` text GENERATED ALWAYS AS ('hello "world"!') VIRTUAL
    );
    ```
    </CodeTab>

    **`callback`** - 테이블의 컬럼을 참조해야 하는 경우

     <CodeTab>
    ```ts
    export const test = mysqlTable("test", {
        name: text("first_name"),
        generatedName: text("gen_name").generatedAlwaysAs(
          (): SQL => sql`'hi, ' || ${test.name} || '!'`
        ),
    });
    ```
    ```sql
    CREATE TABLE `test` (
  	  `first_name` text,
  	  `gen_name` text GENERATED ALWAYS AS ('hi, ' || `test`.`first_name` || '!') VIRTUAL
    );
    ```
    </CodeTab>

    #### 제한사항
    Drizzle Kit은 `push` 명령에 대해 다음과 같은 제한사항이 있습니다:
    1. `push`를 사용하여 generated 제약조건 표현식 및 타입을 변경할 수 없습니다. Drizzle-kit은 이 변경사항을 무시합니다. 이를 작동시키려면 `컬럼을 삭제`하고, `push`한 다음, `새 표현식으로 컬럼을 추가`해야 합니다. 이는 데이터베이스 측의 복잡한 매핑으로 인한 것으로, 스키마 표현식이 데이터베이스 측에서 수정되고 인트로스펙션 시 다른 문자열을 얻게 됩니다. 표현식을 변경했는지 아니면 데이터베이스에 의해 변경 및 포맷되었는지 확신할 수 없습니다. 이러한 컬럼이 generated columns이고 `push`가 주로 로컬 데이터베이스 프로토타이핑에 사용되는 한, generated columns을 `삭제`하고 `생성`하는 것이 빨라야 합니다. 이러한 컬럼이 `generated`이므로 모든 데이터가 복원됩니다
    2. `generate`에는 제한사항이 없어야 합니다

  <CodeTabs items={["schema.ts"]}>
	<CodeTab>
	```typescript copy
    export const users = mysqlTable("users", {
        id: int("id"),
        id2: int("id2"),
        name: text("name"),
        storedGenerated: text("stored_gen").generatedAlwaysAs(
          (): SQL => sql`concat(${users.name}, ' ', 'hello')`,
          { mode: "stored" }
        ),
        virtualGenerated: text("virtual_gen").generatedAlwaysAs(
          (): SQL => sql`concat(${users.name}, ' ', 'hello')`,
          { mode: "virtual" }
        ),
    });
    ```
    ```sql
    CREATE TABLE `users` (
      `id` int,
      `id2` int,
      `name` text,
      `stored_gen` text GENERATED ALWAYS AS (concat(`users`.`name`, ' ', 'hello')) STORED,
      `virtual_gen` text GENERATED ALWAYS AS (concat(`users`.`name`, ' ', 'hello')) VIRTUAL
    );
    ```
    </CodeTab>
  </CodeTabs>
  </Tab>
  <Tab>
    #### 데이터베이스 측
    **타입**: `STORED`, `VIRTUAL`

    **작동 방식**
    - 테이블 스키마에서 표현식으로 정의됩니다.
    - Virtual columns은 읽기 작업 중에 계산됩니다.
    - Stored columns은 쓰기 작업 중에 계산되고 저장됩니다.

    **기능**
    - SELECT, INSERT, UPDATE, DELETE 문에서 사용됩니다.
    - Virtual과 stored 모두 인덱싱할 수 있습니다.
    - NOT NULL 및 기타 제약조건을 지정할 수 있습니다.

    **제한사항**
    - Generated column의 값을 직접 삽입하거나 업데이트할 수 없습니다

    자세한 정보는 [SQLite](https://www.sqlite.org/gencol.html) 문서를 확인하세요

    #### Drizzle 측
    Drizzle에서는 모든 컬럼 타입에 `.generatedAlwaysAs()` 함수를 지정하고 지원되는 SQL 쿼리를 추가하여
    이 컬럼 데이터를 자동으로 생성할 수 있습니다.

    #### 기능
    이 함수는 2가지 방법으로 generated 표현식을 받을 수 있습니다:

    <Callout type='warning' collapsed="1.0.0-beta.12 버전부터 변경된 사항">

    1.0.0-beta.12 이전 버전에서는 `.generatedAlwaysAs()`가 리터럴을 표현식으로 받을 수 있었습니다.

    **`string`**
    <CodeTab>
    ```ts
    export const test = sqliteTable("test", {
        id: int("id").primaryKey(),
        generatedName: text("gen_name").generatedAlwaysAs(`'hello world!'`),
    });
    ```

    ```sql
    CREATE TABLE `test` (
	    `id` integer PRIMARY KEY,
	    `gen_name` text GENERATED ALWAYS AS ('hello world!') VIRTUAL
    );
    ```
    </CodeTab>

    </Callout>

    **`sql`** 태그 - Drizzle이 일부 값을 이스케이프하도록 하려는 경우

    ```ts
    export const test = sqliteTable("test", {
        id: int("id").primaryKey(),
        generatedName: text("gen_name").generatedAlwaysAs(sql`'hello "world"!'`),
    });
    ```
    ```sql
    CREATE TABLE `test` (
      `id` integer PRIMARY KEY,
      `gen_name` text GENERATED ALWAYS AS ('hello "world"!') VIRTUAL
    );
    ```

    **`callback`** - 테이블의 컬럼을 참조해야 하는 경우

    ```ts
    export const test = sqliteTable("test", {
        name: text("first_name"),
        generatedName: text("gen_name").generatedAlwaysAs(
          (): SQL => sql`'hi,' || ${test.name} || '!'`
        ),
    });
    ```
    ```sql
    CREATE TABLE `test` (
      `first_name` text,
      `gen_name` text GENERATED ALWAYS AS ('hi,' || "first_name" || '!') VIRTUAL
    );
    ```

    #### 제한사항
    Drizzle Kit은 `push` 및 `generate` 명령에 대해 다음과 같은 제한사항이 있습니다:
    1. 기존 테이블에서 stored 타입의 generated 제약조건 표현식을 변경할 수 없습니다. 이 테이블을 삭제하고 다시 생성해야 합니다. 이는 이러한 작업에 대한 SQLite의 제한사항 때문입니다. 향후 릴리스에서 이 경우를 처리할 예정입니다(새 테이블 생성 및 데이터 마이그레이션 포함).
    2. 위와 같은 이유로 기존 컬럼에 `stored` generated 표현식을 추가할 수 없습니다. 그러나 기존 컬럼에 `virtual` 표현식을 추가할 수 있습니다.
    3. 위와 같은 이유로 기존 컬럼의 `stored` generated 표현식을 변경할 수 없습니다. 그러나 `virtual` 표현식은 변경할 수 있습니다.
    4. 위와 같은 이유로 generated 제약조건 타입을 `virtual`에서 `stored`로 변경할 수 없습니다. 그러나 `stored`에서 `virtual`로는 변경할 수 있습니다.

  <CodeTabs items={["schema.ts"]}>
	<CodeTab>
	```typescript copy
    export const users = sqliteTable("users", {
      id: int("id"),
      name: text("name"),
      storedGenerated: text("stored_gen").generatedAlwaysAs(
        (): SQL => sql`${users.name} || 'hello'`,
        { mode: "stored" }
      ),
      virtualGenerated: text("virtual_gen").generatedAlwaysAs(
        (): SQL => sql`${users.name} || 'hello'`,
        { mode: "virtual" }
      ),
    });
    ```
    ```sql
    CREATE TABLE `users` (
	    `id` integer,
	    `name` text,
	    `stored_gen` text GENERATED ALWAYS AS ("name" || 'hello') STORED,
	    `virtual_gen` text GENERATED ALWAYS AS ("name" || 'hello') VIRTUAL
    );
    ```
    </CodeTab>
  </CodeTabs>
  </Tab>
  <Tab>
  작업 진행 중
  </Tab>
  <Tab>
    #### 데이터베이스 측
    **타입**: `PERSISTED`, `VIRTUAL`

    **작동 방식**
    - 테이블 스키마에서 표현식으로 정의됩니다.
    - Virtual columns은 읽기 작업 중에 계산됩니다.
    - Persisted columns은 쓰기 작업 중에 계산되고 저장됩니다.

    자세한 정보는 [MSSQL](https://learn.microsoft.com/en-us/sql/relational-databases/tables/specify-computed-columns-in-a-table?view=sql-server-ver17) 문서를 확인하세요

    #### Drizzle 측
    Drizzle에서는 모든 컬럼 타입에 `.generatedAlwaysAs()` 함수를 지정하고 지원되는 SQL 쿼리를 추가하여
    이 컬럼 데이터를 자동으로 생성할 수 있습니다.

    #### 기능
    이 함수는 2가지 방법으로 generated 표현식을 받을 수 있습니다:

    <Callout type='warning' collapsed="1.0.0-beta.12 버전부터 변경된 사항">

    이전 버전에서는 `.generatedAlwaysAs()`가 리터럴을 표현식으로 받을 수 있었습니다.

    **`string`**
    <CodeTab>
    ```ts
    export const test = mssqlTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(`'hello world!'`),
    });
    ```
    ```sql
    CREATE TABLE [test] (
	    [gen_name] AS ('hello world!')
    );
    ```
    </CodeTab>
    </Callout>

    **`sql`** 태그 - Drizzle이 일부 값을 이스케이프하도록 하려는 경우

    <CodeTab>
    ```ts
    export const test = mssqlTable("test", {
        id: int("id"),
        generatedName: text("gen_name").generatedAlwaysAs(sql`hello "world"!`),
    });
    ```
    ```sql
    CREATE TABLE [test] (
	    [id] int,
	    [gen_name] AS ('hello "world"!')
    );
    ```
    </CodeTab>

    **`callback`** - 테이블의 컬럼을 참조해야 하는 경우

    <CodeTab>
    ```ts
    export const test = mssqlTable("test", {
        name: text("first_name"),
        generatedName: text("gen_name").generatedAlwaysAs(
          (): SQL => sql`concat('hi,', ' ', ${test.name}, '!')`
        ),
    });
    ```
    ```sql
    CREATE TABLE [test] (
    	[first_name] text,
    	[gen_name] AS (concat('hi,', ' ', [test].[first_name], '!'))
    );
    ```
    </CodeTab>
  </Tab>
  <Tab>
    Drizzle에서는 모든 컬럼 타입에 `.generatedAlwaysAs()` 함수를 지정하고 지원되는 SQL 쿼리를 추가하여
    이 컬럼 데이터를 자동으로 생성할 수 있습니다.

    #### 기능
    이 함수는 2가지 방법으로 generated 표현식을 받을 수 있습니다:

    <Callout type='warning' collapsed="1.0.0-beta.12 버전부터 변경된 사항">

    이전 버전에서는 `.generatedAlwaysAs()`가 리터럴을 표현식으로 받을 수 있었습니다.

    **`string`**
    <CodeTab>
    ```ts
    export const test = cockroachTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(`'hello world!'`),
    });
    ```
    ```sql
    CREATE TABLE "test" (
    	"gen_name" string GENERATED ALWAYS AS ('hello world!') STORED
    );
    ```
    </CodeTab>
    </Callout>

    **`sql`** 태그 - Drizzle이 일부 값을 이스케이프하도록 하려는 경우

    <CodeTab>
    ```ts
    export const test = cockroachTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(sql`'hello "world"!'`),
    });
    ```
    ```sql
    CREATE TABLE "test" (
	    "gen_name" string GENERATED ALWAYS AS ('hello "world"!') STORED
    );
    ```
    </CodeTab>

    **`callback`** - 테이블의 컬럼을 참조해야 하는 경우
    <CodeTab>
    ```ts
    export const test = cockroachTable("test", {
        name: text("first_name"),
        generatedName: text("gen_name").generatedAlwaysAs(
          (): SQL => sql`'hi, ' || ${test.name} || '!'`
        ),
    });
    ```

    ```sql
    CREATE TABLE "test" (
    	"first_name" string,
    	"gen_name" string GENERATED ALWAYS AS ('hi, ' || "test"."first_name" || '!') STORED
    );
    ```
    </CodeTab>

    **예제** 전체 텍스트 검색을 사용하는 generated columns
   <CodeTabs items={["schema.ts"]}>
	<CodeTab>
	```typescript copy {17-19}
    import { SQL, sql } from "drizzle-orm";
    import { customType, index, int4, cockroachTable, text } from "drizzle-orm/cockroach-core";

    const tsVector = customType<{ data: string }>({
      dataType() {
        return "tsvector";
      },
    });

    export const test = cockroachTable(
      "test",
      {
        id: int4().primaryKey().generatedAlwaysAsIdentity(),
        content: text("content"),
        contentSearch: tsVector("content_search", {
          dimensions: 3,
        }).generatedAlwaysAs(
          (): SQL => sql`to_tsvector('english', ${test.content})`
        ),
      },
      (t) => [
        index("idx_content_search").using("gin", t.contentSearch)
      ]
    );
    ```
    ```sql {4}
    CREATE TABLE "test" (
    	"id" int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY (INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START WITH 1 CACHE 1),
    	"content" string,
    	"content_search" tsvector GENERATED ALWAYS AS (to_tsvector('english', "test"."content")) STORED
    );
    CREATE INDEX "idx_content_search" ON "test" USING gin ("content_search");
    ```
    </CodeTab>
   </CodeTabs>
  </Tab>
</Tabs>
