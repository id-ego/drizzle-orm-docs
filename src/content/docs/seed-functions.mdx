import Callout from '@mdx/Callout.astro';
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";

# 생성자 함수

<Callout title='warning'>
현재로서는 `arraySize`와 `isUnique`를 함께 지정하면 고유한 배열이 아닌 고유한 값들이 생성되고, 이 값들이 배열로 묶입니다.
</Callout>

## ---

### `default`

<rem025 />
생성자가 호출될 때마다 동일한 값을 생성합니다.

|  | param          | default     | type
|:-| :--------      | :--------   | :--------
|  |`defaultValue`  |--           |`any`
|  |`arraySize`     |--           |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  posts: {
    columns: {
      content: funcs.default({
        // 생성하려는 값
        defaultValue: "post content",

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `valuesFromArray`

<rem025 />
주어진 배열에서 값을 생성합니다.

|  | param      | default                     | type
|:-| :--------  | :--------                   | :--------
|  |`values`    |--                           |`any[]` \| `{ weight: number; values: any[] }[]`
|  |`isUnique`  |`database column uniqueness` |`boolean`
|  |`arraySize` |--                           |`number`


<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  posts: {
    columns: {
      title: funcs.valuesFromArray({
        // 생성하려는 값의 배열 (가중치가 적용된 값의 배열도 가능)
        values: ["Title1", "Title2", "Title3", "Title4", "Title5"],

        // 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `intPrimaryKey`

<rem025 />
1부터 시작하는 순차적인 정수를 생성합니다.

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |--          |--          |--

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  posts: {
    columns: {
      id: funcs.intPrimaryKey(),
    },
  },
}));

```

### `number`

<rem025 />
주어진 범위 내에서 부동소수점 숫자를 생성합니다.

|  | param      | default                                                                                               | type
|:-| :--------  | :--------                                                                                             | :--------
|  |`isUnique`  |`database column uniqueness`                                                                           |`boolean`
|  |`precision` |`100`                                                                                                  |`number`
|  |`maxValue`  |``` `precision * 1000` if isUnique equals false``` ``` `precision * count` if isUnique equals true```  |`number`
|  |`minValue`  |`-maxValue`                                                                                            |`number`
|  |`arraySize` |--                                                                                                     |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  products: {
    columns: {
      unitPrice: funcs.number({
        // 범위의 최솟값
        minValue: 10,

        // 범위의 최댓값
        maxValue: 120,

        // 생성된 숫자의 정밀도:
        // precision이 10이면 값이 소수점 첫째 자리까지 정확함 (1.2, 34.6);
        // precision이 100이면 값이 소수점 둘째 자리까지 정확함 (1.23, 34.67).
        precision: 100,

        // 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: false,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `int`

<rem025 />
주어진 범위 내에서 정수를 생성합니다.

|  | param      | default                                                                            | type
|:-| :--------  | :--------                                                                          | :--------
|  |`isUnique`  |`database column uniqueness`                                                        |`boolean`
|  |`maxValue`  |``` `1000` if isUnique equals false``` ``` `count * 10` if isUnique equals true```  |`number \| bigint`
|  |`minValue`  |`-maxValue`                                                                         |`number \| bigint`
|  |`arraySize` |--                                                                                  |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  products: {
    columns: {
      unitsInStock: funcs.int({
        // 범위의 최솟값
        minValue: 0,

        // 범위의 최댓값
        maxValue: 100,

        // 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: false,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `boolean`

<rem025 />
불리언 값(true 또는 false)을 생성합니다.

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      isAvailable: funcs.boolean({
        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `date`

<rem025 />
주어진 범위 내에서 날짜를 생성합니다.

|  | param      | default                 | type
|:-| :--------  | :--------------         | :--------
|  |`minDate`   |`new Date('2020-05-08')` | `string \| Date`
|  |`maxDate`   |`new Date('2028-05-08')` | `string \| Date`
|  |`arraySize` |--                       |`number`

<Callout type='warning'>
`minDate` 또는 `maxDate` 중 하나만 제공되면, 지정되지 않은 매개변수는 지정된 값에서 8년을 더하거나 빼서 계산됩니다.
</Callout>

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      birthDate: funcs.date({
        // 범위의 최솟값
        minDate: "1990-01-01",

        // 범위의 최댓값
        maxDate: "2010-12-31",

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `time`

<rem025 />
24시간 형식의 시간을 생성합니다.

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      birthTime: funcs.time({
        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `timestamp`

<rem025 />
타임스탬프를 생성합니다.

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  orders: {
    columns: {
      shippedDate: funcs.timestamp({
        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `datetime`

<rem025 />
datetime 객체를 생성합니다.

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`
<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  orders: {
    columns: {
      shippedDate: funcs.datetime({
        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `year`

<rem025 />
`YYYY` 형식의 연도를 생성합니다.

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      birthYear: funcs.year({
        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `json`

<rem025 />
고정된 구조의 JSON 객체를 생성합니다.

```ts
{ email, name, isGraduated, hasJob, salary, startedWorking, visitedCountries}

// or

{ email, name, isGraduated, hasJob, visitedCountries }
```

> JSON 구조는 무작위로 선택됩니다.

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      metadata: funcs.json({
        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `interval`

<rem025 />
시간 간격을 생성합니다.

생성된 값의 예: `1 year 12 days 5 minutes`

|  | param      | default                     | type
|:-| :--------  | :--------                   | :--------
|  |`isUnique`  |`database column uniqueness` |`boolean`
|  |`arraySize` |--                           |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      timeSpentOnWebsite: funcs.interval({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `string`

<rem025 />
무작위 문자열을 생성합니다.

|  | param      | default                     | type
|:-| :--------  | :--------                   | :--------
|  |`isUnique`  |`database column uniqueness` |`boolean`
|  |`arraySize` |--                           |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      hashedPassword: funcs.string({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: false,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `uuid`

<rem025 />
v4 UUID 문자열을 생성합니다.

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";
await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  products: {
    columns: {
      id: funcs.uuid({
        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));
```

### `firstName`

<rem025 />
사람의 이름을 생성합니다.

|  | param      | default                     | type
|:-| :--------  | :--------                   | :--------
|  |`isUnique`  |`database column uniqueness` |`boolean`
|  |`arraySize` |--                           |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      firstName: funcs.firstName({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `lastName`

<rem025 />
사람의 성을 생성합니다.

|  | param      | default                     | type
|:-| :--------  | :--------                   | :--------
|  |`isUnique`  |`database column uniqueness` |`boolean`
|  |`arraySize` |--                           |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      lastName: funcs.lastName({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: false,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `fullName`

<rem025 />
사람의 전체 이름을 생성합니다.

|  | param      | default                     | type
|:-| :--------  | :--------                   | :--------
|  |`isUnique`  |`database column uniqueness` |`boolean`
|  |`arraySize` |--                           |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      fullName: funcs.fullName({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `email`

<rem025 />
고유한 이메일 주소를 생성합니다.

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      email: funcs.email({
        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `phoneNumber`

<rem025 />
고유한 전화번호를 생성합니다.

|  | param                    | default                                         | type
|:-| :--------                | :--------                                       | :--------
|  |`template`                |--                                               |`string`
|  |`prefixes`                |[Used dataset for prefixes](https://github.com/OleksiiKH0240/drizzle-orm/blob/main/drizzle-seed/src/datasets/phonesInfo.ts)   |`string[]`
|  |`generatedDigitsNumbers`  | `7` - `if prefixes was defined`                 |`number \| number[]`
|  |`arraySize`               |--                                               |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

//template 속성을 사용하여 전화번호 생성
await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      phoneNumber: funcs.phoneNumber({
        // `template` - 전화번호 템플릿, 모든 '#' 기호가 생성된 숫자로 대체됩니다
        template: "+(380) ###-####",

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```
```ts 
import { seed } from "drizzle-seed";

//prefixes와 generatedDigitsNumbers 속성을 사용하여 전화번호 생성
await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      phoneNumber: funcs.phoneNumber({
        // `prefixes` - 전화번호 접두사로 사용할 문자열 배열 (`template` 속성과 호환되지 않음)
        prefixes: ["+380 99", "+380 67"],

        // `generatedDigitsNumbers` - 접두사 끝에 추가될 숫자의 개수 (`template` 속성과 호환되지 않음)
        generatedDigitsNumbers: 7,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```
```ts 
import { seed } from "drizzle-seed";

// prefixes와 generatedDigitsNumbers 속성을 사용하되 접두사마다 다른 generatedDigitsNumbers로 전화번호 생성
await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      phoneNumber: funcs.phoneNumber({
        // `prefixes` - 전화번호 접두사로 사용할 문자열 배열 (`template` 속성과 호환되지 않음)
        prefixes: ["+380 99", "+380 67", "+1"],

        // `generatedDigitsNumbers` - 접두사 끝에 추가될 숫자의 개수 (`template` 속성과 호환되지 않음)
        generatedDigitsNumbers: [7, 7, 10],

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```
### `country`

<rem025 />
국가 이름을 생성합니다.

|  | param      | default                     | type
|:-| :--------  | :--------                   | :--------
|  |`isUnique`  |`database column uniqueness` |`boolean`
|  |`arraySize` |--                           |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      country: funcs.country({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: false,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `city`

<rem025 />
도시 이름을 생성합니다.

|  | param      | default                     | type
|:-| :--------  | :--------                   | :--------
|  |`isUnique`  |`database column uniqueness` |`boolean`
|  |`arraySize` |--                           |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      city: funcs.city({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: false,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `streetAddress`

<rem025 />
거리 주소를 생성합니다.

|  | param      | default                     | type
|:-| :--------  | :--------                   | :--------
|  |`isUnique`  |`database column uniqueness` |`boolean`
|  |`arraySize` |--                           |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      streetAddress: funcs.streetAddress({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: false,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `jobTitle`

<rem025 />
직업 명칭을 생성합니다.

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      jobTitle: funcs.jobTitle({
        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `postcode`

<rem025 />
우편번호를 생성합니다.

|  | param      | default                     | type
|:-| :--------  | :--------                   | :--------
|  |`isUnique`  |`database column uniqueness` |`boolean`
|  |`arraySize` |--                           |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      postcode: funcs.postcode({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `state`

<rem025 />
미국 주 이름을 생성합니다.

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      state: funcs.state({
        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `companyName`

<rem025 />
무작위 회사 이름을 생성합니다.

|  | param      | default                     | type
|:-| :--------  | :--------                   | :--------
|  |`isUnique`  |`database column uniqueness` |`boolean`
|  |`arraySize` |--                           |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      company: funcs.companyName({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```
### `loremIpsum`

<rem025 />
`lorem ipsum` 텍스트 문장을 생성합니다.

|  | param            | default    | type
|:-| :--------        | :--------  | :--------
|  |`sentencesCount`  | 1          |`number`
|  |`arraySize`       |--          |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  posts: {
    columns: {
      content: funcs.loremIpsum({
        // `sentencesCount` - 하나의 생성된 값(문자열)으로 생성할 문장 수
        sentencesCount: 2,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `point`

<rem025 />
x와 y 좌표에 대해 지정된 범위 내에서 2D 포인트를 생성합니다.

|  | param       | default                                                                                 | type
|:-| :--------   | :--------                                                                               | :--------
|  |`isUnique`   |`database column uniqueness`                                                             |`boolean`
|  |`maxXValue`  |``` `10 * 1000` if isUnique equals false``` ``` `10 * count` if isUnique equals true```  |`number`
|  |`minXValue`  |`-maxXValue`                                                                             |`number`
|  |`maxYValue`  |``` `10 * 1000` if isUnique equals false``` ``` `10 * count` if isUnique equals true```  |`number`
|  |`minYValue`  |`-maxYValue`                                                                             |`number`
|  |`arraySize`  |--                                                                                       |`number`


<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  triangles: {
    columns: {
      pointCoords: funcs.point({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // `minXValue` - x 좌표 범위의 최솟값
        minXValue: -5,

        // `maxXValue` - x 좌표 범위의 최댓값
        maxXValue: 20,

        // `minYValue` - y 좌표 범위의 최솟값
        minYValue: 0,

        // `maxYValue` - y 좌표 범위의 최댓값
        maxYValue: 30,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `line`

<rem025 />
직선의 a, b, c 매개변수에 대해 지정된 범위 내에서 2D 직선을 생성합니다.

```
line equation: a*x + b*y + c = 0
```

|  | param       | default                                                                                 | type
|:-| :--------   | :--------                                                                               | :--------
|  |`isUnique`   |`database column uniqueness`                                                             |`boolean`
|  |`maxAValue`  |``` `10 * 1000` if isUnique equals false``` ``` `10 * count` if isUnique equals true```  |`number`
|  |`minAValue`  |`-maxAValue`                                                                             |`number`
|  |`maxBValue`  |``` `10 * 1000` if isUnique equals false``` ``` `10 * count` if isUnique equals true```  |`number`
|  |`minBValue`  |`-maxBValue`                                                                             |`number`
|  |`maxCValue`  |``` `10 * 1000` if isUnique equals false``` ``` `10 * count` if isUnique equals true```  |`number`
|  |`minCValue`  |`-maxCValue`                                                                             |`number`
|  |`arraySize`  |--                                                                                       |`number`
<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  lines: {
    columns: {
      lineParams: funcs.point({
        // `isUnique` - 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // `minAValue` - a 매개변수 범위의 최솟값
        minAValue: -5,

        // `maxAValue` - a 매개변수 범위의 최댓값
        maxAValue: 20,

        // `minBValue` - b 매개변수 범위의 최솟값
        minBValue: 0,

        // `maxBValue` - b 매개변수 범위의 최댓값
        maxBValue: 30,

        // `minCValue` - c 매개변수 범위의 최솟값
        minCValue: 0,

        // `maxCValue` - c 매개변수 범위의 최댓값
        maxCValue: 10,

        // 1차원 배열의 요소 개수
        // (지정하면 배열이 생성됩니다)
        arraySize: 3
      }),
    },
  },
}));

```

### `bitString`

<rem025 />
지정된 매개변수를 기반으로 비트 문자열을 생성합니다.

|  | param       | default                                                                                 | type
|:-| :--------   | :--------                                                                               | :--------
|  |`isUnique`   |`database column uniqueness`                                                             |`boolean`
|  |`dimensions` |`database column bit-length`                                                             |`number`
|  |`arraySize`  |--                                                                                       |`number`
<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  bitStringTable: {
    columns: {
      bit: funcs.bitString({
        // 각 비트 문자열의 원하는 길이 (예: `dimensions = 3`은 `'010'`과 같은 값을 생성함)
        dimensions: 12,

        // 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // 1차원 배열의 요소 개수 (지정하면 배열이 생성됩니다)
        arraySize: 3,
      }),
    },
  },
}));

```

### `inet`

<rem025 />
지정된 매개변수를 기반으로 IP 주소를 생성합니다.

|  | param       | default                                                                                 | type
|:-| :--------   | :--------                                                                               | :--------
|  |`isUnique`   |`database column uniqueness`                                                             |`boolean`
|  |`arraySize`  |--                                                                                       |`number`
|  |`ipAddress`  |`'ipv4'`                                                                                 |`'ipv4' \| 'ipv6'`
|  |`includeCidr`|`true`                                                                                   |`boolean`
<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  inetTable: {
    columns: {
      inet: funcs.inet({
        // 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // 1차원 배열의 요소 개수 (지정하면 배열이 생성됩니다)
        arraySize: 3,

        // 생성할 IP 주소 유형 — "ipv4" 또는 "ipv6"
        ipAddress: "ipv4",

        // 생성된 IP에 CIDR 접미사를 포함할지 여부를 결정합니다
        includeCidr: true,
      }),
    },
  },
}));
```

### `geometry`

<rem025 />
주어진 매개변수를 기반으로 geometry 객체를 생성합니다.

<Callout title='warnings'>
<Tabs items={['arraySize', 'srid']}>
<Tab>
현재 arraySize를 1보다 큰 값으로 설정하거나
drizzle-orm을 통해 PostgreSQL 또는 CockroachDB의 `geometry(point, 0)[]` 컬럼에 둘 이상의 `geometry point` 요소를 삽입하려고 하면
오류가 발생합니다.

이 버그는 이미 백로그에 등록되어 있습니다.

<Callout title="❌">
```ts {13}
import { seed } from "drizzle-seed";
import { geometry, pgTable } from 'drizzle-orm/pg-core';

const geometryTable = pgTable('geometry_table', {
	geometryArray: geometry('geometry_array', { type: 'point', srid: 0 }).array(3),
});

await seed(db, { geometryTable }, { count: 1000 }).refine((funcs) => ({
  geometryTable: {
    columns: {
      geometryArray: funcs.geometry({
        // 현재 1보다 큰 값의 arraySize는 지원되지 않습니다
        arraySize: 3,
      }),
    },
  },
}));
```
</Callout>

<Callout title='✅'>
```ts {13}
import { seed } from "drizzle-seed";
import { geometry, pgTable } from 'drizzle-orm/pg-core';

const geometryTable = pgTable('geometry_table', {
	geometryArray: geometry('geometry_array', { type: 'point', srid: 0 }).array(1),
});

await seed(db, { geometryTable }, { count: 1000 }).refine((funcs) => ({
  geometryTable: {
    columns: {
      geometryArray: funcs.geometry({
        // 예상대로 작동합니다
        arraySize: 1,
      }),
    },
  },
}));
```
</Callout>
</Tab>

<Tab>
현재 drizzle-orm 테이블 선언에서 `geometry(point)` 컬럼의 SRID를 0이 아닌 다른 값(예: 4326)으로 설정하면
시딩 과정에서 오류가 발생합니다.

이 버그는 이미 백로그에 등록되어 있습니다.

<Callout title="❌">
```ts {5}
import { seed } from "drizzle-seed";
import { geometry, pgTable } from 'drizzle-orm/pg-core';

const geometryTable = pgTable('geometry_table', {
	geometryColumn: geometry('geometry_column', { type: 'point', srid: 4326 }),
});

await seed(db, { geometryTable }, { count: 1000 }).refine((funcs) => ({
  geometryTable: {
    columns: {
      geometryColumn: funcs.geometry({
        srid: 4326,
      }),
    },
  },
}));
```
</Callout>

<Callout title='✅'>
```ts {5}
import { seed } from "drizzle-seed";
import { geometry, pgTable } from 'drizzle-orm/pg-core';

const geometryTable = pgTable('geometry_table', {
	geometryColumn: geometry('geometry_column', { type: 'point', srid: 0 }),
});

await seed(db, { geometryTable }, { count: 1000 }).refine((funcs) => ({
  geometryTable: {
    columns: {
      geometryColumn: funcs.geometry({
        srid: 4326,
      }),
    },
  },
}));
```
</Callout>
</Tab>
</Tabs>
</Callout>

|  | param          | default                                                                                 | type
|:-| :--------      | :--------                                                                               | :--------
|  |`isUnique`      |`database column uniqueness`                                                             |`boolean`
|  |`arraySize`     |--                                                                                       |`number`
|  |`type`          |`'point'`                                                                                |`'point'`
|  |`srid`          |`4326`                                                                                   |`4326 \| 3857`
|  |`decimalPlaces` |`6`                                                                                      |`1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7`
<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  geometryTable: {
    columns: {
      geometryPointTuple: funcs.geometry({
        // 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // 1차원 배열의 요소 개수 (지정하면 배열이 생성됩니다)
        arraySize: 1,

        // 생성할 geometry 타입; 현재는 `'point'`만 지원됩니다
        type: "point",

        // 공간 참조 시스템 식별자: 생성될 포인트 유형을 결정합니다 - `4326` 또는 `3857`
        srid: 4326,

        // `srid`가 `4326`일 때 포인트의 소수점 자릿수 (예: `decimalPlaces = 3`은 `'point(30.723 46.482)'`와 같은 값을 생성함)
        decimalPlaces: 5,
      }),
    },
  },
}));

```

### `vector`

<rem025 />
제공된 매개변수를 기반으로 벡터를 생성합니다.

|  | param          | default                                                      | type
|:-| :--------      | :--------                                                    | :--------
|  |`isUnique`      |`database column uniqueness`                                  |`boolean`
|  |`arraySize`     |--                                                            |`number`
|  |`decimalPlaces` |`2`                                                           |`number`
|  |`dimensions`    |`database column’s dimensions`                                |`number`
|  |`minValue`      |`-1000`                                                       |`number`
|  |`maxValue`      |`1000`                                                        |`number`
<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  vectorTable: {
    columns: {
      vector: funcs.vector({
        // 생성된 값의 고유성 여부를 제어하는 속성
        isUnique: true,

        // 1차원 배열의 요소 개수 (지정하면 배열이 생성됩니다)
        arraySize: 3,

        // 각 벡터 요소의 소수점 자릿수 (예: `decimalPlaces = 3`은 `1.123`과 같은 값을 생성함)
        decimalPlaces: 5,

        // 각 생성된 벡터의 요소 개수 (예: `dimensions = 3`은 `[1,2,3]`과 같은 값을 생성함)
        dimensions: 12,

        // 각 벡터 요소에 허용되는 최솟값
        minValue: -100,

        // 각 벡터 요소에 허용되는 최댓값
        maxValue: 100,
      }),
    },
  },
}));

```