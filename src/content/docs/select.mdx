import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import Callout from '@mdx/Callout.astro';
import Section from '@mdx/Section.astro';
import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import $count from '@mdx/$count.mdx';

# SQL Select
Drizzle은 타입 안정성과 조합 가능성을 유지하면서 데이터베이스에서 데이터를 가져오는 가장 SQL과 유사한 방법을 제공합니다. 모든 방언의 거의 모든 쿼리 기능을 기본적으로 지원하며, 아직 지원하지 않는 기능은 강력한 [`sql`](/docs/sql) 연산자를 사용하여 추가할 수 있습니다.

다음 예제에서는 이와 같이 정의된 `users` 테이블이 있다고 가정합니다:
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore', 'MSSQL', 'CockroachDB']}>
<Tab>
```typescript
import { pgTable, serial, text } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age'),
});
```
</Tab>
<Tab>
```typescript
import { mysqlTable, serial, text, int } from 'drizzle-orm/mysql-core';

export const users = mysqlTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: int('age'),
});
```
</Tab>
<Tab>
```typescript
import { sqliteTable, integer, text } from 'drizzle-orm/sqlite-core';

export const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age'),
});
```
</Tab>
<Tab>
```typescript
import { singlestoreTable, serial, text, int } from 'drizzle-orm/singlestore-core';

export const users = singlestoreTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
  age: int('age'),
});
```
</Tab>
<Tab>
```typescript
import { mssqlTable, int, text } from 'drizzle-orm/mssql-core';

export const users = pgTable('users', {
  id: int().primaryKey(),
  name: text().notNull(),
  age: int(),
});
```
</Tab>
<Tab>
```typescript
import { cockroachTable, int4, text } from 'drizzle-orm/cockroach-core';

export const users = pgTable('users', {
  id: int4().primaryKey(),
  name: text().notNull(),
  age: int4(),
});
```
</Tab>
</Tabs>

### 기본 조회
테이블의 모든 행을 모든 컬럼을 포함하여 조회합니다:

<Section>
```typescript
const result = await db.select().from(users);
/*
  {
    id: number;
    name: string;
    age: number | null;
  }[]
*/
```
```sql
select "id", "name", "age" from "users";
```
</Section>

결과 타입은 컬럼의 null 허용 여부를 포함하여 테이블 정의를 기반으로 자동으로 추론됩니다.

<Callout type="info">
Drizzle은 `select *` 대신 항상 `select` 절에 컬럼을 명시적으로 나열합니다.<br />
이는 쿼리 결과에서 필드 순서를 보장하기 위해 내부적으로 필요하며, 일반적으로 좋은 관행으로 간주됩니다.
</Callout>

### 부분 조회
경우에 따라 테이블에서 일부 컬럼만 조회하고 싶을 수 있습니다. `.select()` 메서드에 선택 객체를 제공하여 이를 수행할 수 있습니다:
<Section>
```typescript copy
const result = await db.select({
  field1: users.id,
  field2: users.name,
}).from(users);

const { field1, field2 } = result[0];
```
```sql
select "id", "name" from "users";
```
</Section>

SQL처럼 테이블 컬럼뿐만 아니라 임의의 표현식을 선택 필드로 사용할 수 있습니다:

<Section>
```typescript
const result = await db.select({
  id: users.id,
  lowerName: sql<string>`lower(${users.name})`,
}).from(users);
```
```sql
select "id", lower("name") from "users";
```
</Section>

<Callout type="warning">
`sql<string>`을 지정하면 필드의 **예상** 타입이 `string`임을 Drizzle에 알리는 것입니다.<br />
잘못 지정하면 (예: 문자열로 반환될 필드에 `sql<number>` 사용) 런타임 값이 예상 타입과 일치하지 않습니다. Drizzle은 제공된 타입 제네릭을 기반으로 타입 캐스트를 수행할 수 없습니다. 해당 정보는 런타임에 사용할 수 없기 때문입니다.

반환된 값에 런타임 변환을 적용해야 하는 경우 [`.mapWith()`](/docs/sql#sqlmapwith) 메서드를 사용할 수 있습니다.
</Callout>

<Callout title='참고'>
`v1.0.0-beta.1`부터 컬럼에 `.as()`를 사용할 수 있습니다:

```ts
const result = await db.select({
  id: users.id,
  lowerName: users.name.as("lower"),
}).from(users);
```
</Callout>

### 조건부 조회

조건에 따라 동적 선택 객체를 가질 수 있습니다:

```typescript
async function selectUsers(withName: boolean) {
  return db
    .select({
      id: users.id,
      ...(withName ? { name: users.name } : {}),
    })
    .from(users);
}

const users = await selectUsers(true);
```

### Distinct 조회

데이터셋에서 고유한 행만 검색하려면 `.select()` 대신 `.selectDistinct()`를 사용할 수 있습니다:
<Section>
```ts
await db.selectDistinct().from(users).orderBy(users.id, users.name);

await db.selectDistinct({ id: users.id }).from(users).orderBy(users.id);
```
```sql
select distinct "id", "name" from "users" order by "id", "name";

select distinct "id" from "users" order by "id";
```
</Section>

PostgreSQL에서는 `distinct on` 절을 사용하여 고유한 행이 결정되는 방식을 지정할 수도 있습니다:
<Callout type='warning'>
`distinct on` 절은 PostgreSQL에서만 지원됩니다.
</Callout>
<Section>
```ts
await db.selectDistinctOn([users.id]).from(users).orderBy(users.id);
await db.selectDistinctOn([users.name], { name: users.name }).from(users).orderBy(users.name);
```
```sql
select distinct on ("id") "id", "name" from "users" order by "id";
select distinct on ("name") "name" from "users" order by "name";
```
</Section>



### 고급 조회
TypeScript를 기반으로 Drizzle API를 사용하면 다양하고 유연한 방식으로 조회 쿼리를 작성할 수 있습니다.

고급 부분 조회 미리보기입니다. 더 자세한 고급 사용 예제는 [전용 가이드](/docs/guides/include-or-exclude-columns)를 참조하세요.

<Callout type='warning'>
`getColumns`는 `drizzle-orm@1.0.0-beta.2`부터 사용 가능합니다([여기](/docs/upgrade-v1)에서 자세히 읽기)

pre-1 버전(예: `0.45.1`)을 사용하는 경우 `getTableColumns`를 사용하세요
</Callout>


<br/>

<CodeTabs items={["example 1", "example 2", "example 3", "example 4"]}>
```ts
import { getColumns, sql } from 'drizzle-orm';

await db.select({
    ...getColumns(posts),
    titleLength: sql<number>`length(${posts.title})`,
  }).from(posts);
```
```ts
import { getColumns } from 'drizzle-orm';

const { content, ...rest } = getColumns(posts); // exclude "content" column
await db.select({ ...rest }).from(posts); // select all other columns
```
```ts
await db.query.posts.findMany({
  columns: {
    title: true,
  },
});
```
```ts
await db.query.posts.findMany({
  columns: {
    content: false,
  },
});
```
</CodeTabs>

## ---

### 필터

`.where()` 메서드에서 [필터 연산자](/docs/operators)를 사용하여 쿼리 결과를 필터링할 수 있습니다:

<Section>
```typescript copy
import { eq, lt, gte, ne } from 'drizzle-orm';

await db.select().from(users).where(eq(users.id, 42));
await db.select().from(users).where(lt(users.id, 42));
await db.select().from(users).where(gte(users.id, 42));
await db.select().from(users).where(ne(users.id, 42));
...
```
```sql
select "id", "name", "age" from "users" where "id" = 42;
select "id", "name", "age" from "users" where "id" < 42;
select "id", "name", "age" from "users" where "id" >= 42;
select "id", "name", "age" from "users" where "id" <> 42;
```
</Section>

모든 필터 연산자는 [`sql`](/docs/sql) 함수를 사용하여 구현됩니다. 이를 직접 사용하여 임의의 SQL 필터를 작성하거나 자신만의 연산자를 만들 수 있습니다. 영감을 얻으려면 Drizzle에서 제공하는 연산자가 어떻게 [구현](https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sql/expressions/conditions.ts)되었는지 확인할 수 있습니다.
<Section>
```typescript copy
import { sql } from 'drizzle-orm';

function equals42(col: Column) {
  return sql`${col} = 42`;
}

await db.select().from(users).where(sql`${users.id} < 42`);
await db.select().from(users).where(sql`${users.id} = 42`);
await db.select().from(users).where(equals42(users.id));
await db.select().from(users).where(sql`${users.id} >= 42`);
await db.select().from(users).where(sql`${users.id} <> 42`);
await db.select().from(users).where(sql`lower(${users.name}) = 'aaron'`);
```
```sql
select "id", "name", "age" from "users" where 'id' < 42;
select "id", "name", "age" from "users" where 'id' = 42;
select "id", "name", "age" from "users" where 'id' = 42;
select "id", "name", "age" from "users" where 'id' >= 42;
select "id", "name", "age" from "users" where 'id' <> 42;
select "id", "name", "age" from "users" where lower("name") = 'aaron';
```
</Section>

<Callout type='info'>
필터 연산자와 `sql` 함수에 제공된 모든 값은 자동으로 매개변수화됩니다. 예를 들어, 다음 쿼리는:
```ts
await db.select().from(users).where(eq(users.id, 42));
```
다음과 같이 변환됩니다:
```sql
select "id", "name", "age" from "users" where "id" = $1; -- params: [42]
```
</Callout>

`not` 연산자로 조건을 반전시키기:
<Section>
```typescript copy
import { eq, not, sql } from 'drizzle-orm';

await db.select().from(users).where(not(eq(users.id, 42)));
await db.select().from(users).where(sql`not ${users.id} = 42`);
```
```sql
select "id", "name", "age" from "users" where not ("id" = 42);
select "id", "name", "age" from "users" where not ("id" = 42);
```
</Section>

<Callout type="info">
스키마를 안전하게 변경하고 테이블과 컬럼의 이름을 변경할 수 있으며, 템플릿 보간 덕분에 쿼리에 자동으로 반영됩니다. 원시 SQL을 작성할 때 컬럼이나 테이블 이름을 하드코딩하는 것과 대조적입니다.
</Callout>

### 필터 조합
`and()` 및 `or()` 연산자로 필터 연산자를 논리적으로 결합할 수 있습니다:
<Section>
```typescript copy
import { eq, and, sql } from 'drizzle-orm';

await db.select().from(users).where(
  and(
    eq(users.id, 42),
    eq(users.name, 'Dan')
  )
);
await db.select().from(users).where(sql`${users.id} = 42 and ${users.name} = 'Dan'`);
```
```sql
select "id", "name", "age" from "users" where "id" = 42 and "name" = 'Dan';
select "id", "name", "age" from "users" where "id" = 42 and "name" = 'Dan';
```
</Section>

<Section>
```typescript copy
import { eq, or, sql } from 'drizzle-orm';

await db.select().from(users).where(
  or(
    eq(users.id, 42),
    eq(users.name, 'Dan')
  )
);
await db.select().from(users).where(sql`${users.id} = 42 or ${users.name} = 'Dan'`);
```
```sql
select "id", "name", "age" from "users" where "id" = 42 or "name" = 'Dan';
select "id", "name", "age" from "users" where "id" = 42 or "name" = 'Dan';
```
</Section>

### 고급 필터
TypeScript와 결합하여 Drizzle API는 쿼리에서 필터를 결합하는 강력하고 유연한 방법을 제공합니다.

조건부 필터링 미리보기입니다. 더 자세한 고급 사용 예제는 [전용 가이드](/docs/guides/conditional-filters-in-query)를 참조하세요.
<CodeTabs items={["example 1", "example 2"]}>
```ts
const searchPosts = async (term?: string) => {
  await db
    .select()
    .from(posts)
    .where(term ? ilike(posts.title, term) : undefined);
};
await searchPosts();
await searchPosts('AI');
```
```ts
const searchPosts = async (filters: SQL[]) => {
  await db
    .select()
    .from(posts)
    .where(and(...filters));
};
const filters: SQL[] = [];
filters.push(ilike(posts.title, 'AI'));
filters.push(inArray(posts.category, ['Tech', 'Art', 'Science']));
filters.push(gt(posts.views, 200));
await searchPosts(filters);
```
</CodeTabs>

## ---

### Limit & offset
<IsSupportedChipGroup chips={{ 'MSSQL': false }} />

`.limit()` 및 `.offset()`을 사용하여 쿼리에 `limit` 및 `offset` 절을 추가합니다 - 예를 들어 페이지네이션을 구현하려면:
<Section>
```typescript
await db.select().from(users).limit(10);
await db.select().from(users).limit(10).offset(10);
```
```sql
select "id", "name", "age" from "users" limit 10;
select "id", "name", "age" from "users" limit 10 offset 10;
```
</Section>

### Fetch & offset

<IsSupportedChipGroup chips={{ 'MSSQL': true }} />

<Callout>
MSSQL에서 `FETCH`와 `OFFSET`은 `ORDER BY` 절의 일부이므로 `.orderBy()` 함수 이후에만 사용할 수 있습니다
</Callout>

<Section>
```typescript
await db.select().from(users).orderBy(asc(users.id)).offset(5);
await db.select().from(users).orderBy(asc(users.id)).offset(5).fetch(10);
```
```sql
select [id], [name], [age] from [users] offset 5 rows;
select [id], [name], [age] from [users] offset 5 rows fetch next 10 rows;
```
</Section>

### Top

<IsSupportedChipGroup chips={{ 'MSSQL': true }} />

쿼리 결과 집합에서 반환되는 행을 지정된 수의 행으로 제한합니다

<Section>
```typescript
await db.select().from(users).top(10);
```
```sql
select top (10) [id], [name], [age] from [users];
```
</Section>

### Order By
`.orderBy()`를 사용하여 쿼리에 `order by` 절을 추가하고, 지정된 필드를 기준으로 결과를 정렬합니다:
<Section>
```typescript
import { asc, desc } from 'drizzle-orm';

await db.select().from(users).orderBy(users.name);
await db.select().from(users).orderBy(desc(users.name));

// order by multiple fields
await db.select().from(users).orderBy(users.name, users.name2);
await db.select().from(users).orderBy(asc(users.name), desc(users.name2));
```
```sql
select "id", "name", "age" from "users" order by "name";
select "id", "name", "age" from "users" order by "name" desc;

select "id", "name", "age" from "users" order by "name", "name2";
select "id", "name", "age" from "users" order by "name" asc, "name2" desc;
```
</Section>

### 고급 페이지네이션
TypeScript를 기반으로 Drizzle API를 사용하면 가능한 모든 SQL 페이지네이션 및 정렬 접근 방식을 구현할 수 있습니다.

고급 페이지네이션 미리보기입니다. 더 자세한 고급 사용 예제는 [limit offset 페이지네이션](/docs/guides/limit-offset-pagination) 및 [커서 페이지네이션](/docs/guides/cursor-based-pagination) 가이드를 참조하세요.

<CodeTabs items={["example 1", "example 2", "example 3", "example 4"]}>
```ts
await db
  .select()
  .from(users)
  .orderBy(asc(users.id)) // order by is mandatory
  .limit(4) // the number of rows to return
  .offset(4); // the number of rows to skip
```
```ts
const getUsers = async (page = 1, pageSize = 3) => {
  await db.query.users.findMany({
    orderBy: (users, { asc }) => asc(users.id),
    limit: pageSize,
    offset: (page - 1) * pageSize,
  });
};
await getUsers();
```
```ts
const getUsers = async (page = 1, pageSize = 10) => {
   const sq = db
    .select({ id: users.id })
    .from(users)
    .orderBy(users.id)
    .limit(pageSize)
    .offset((page - 1) * pageSize)
    .as('subquery');
   await db.select().from(users).innerJoin(sq, eq(users.id, sq.id)).orderBy(users.id);
};
```
```ts
const nextUserPage = async (cursor?: number, pageSize = 3) => {
  await db
    .select()
    .from(users)
    .where(cursor ? gt(users.id, cursor) : undefined) // if cursor is provided, get rows after it
    .limit(pageSize) // the number of rows to return
    .orderBy(asc(users.id)); // ordering
};
// pass the cursor of the last row of the previous page (id)
await nextUserPage(3);
```
</CodeTabs>

## ---

### WITH 절

<Callout>
  [insert](/docs/insert#with-insert-clause), [update](/docs/update#with-update-clause), [delete](/docs/delete#with-delete-clause)에서 WITH 문을 사용하는 방법을 확인하세요
</Callout>

`with` 절을 사용하면 복잡한 쿼리를 CTE(Common Table Expression)라는 작은 하위 쿼리로 분할하여 단순화할 수 있습니다:
<Section>
```typescript copy
const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));

const result = await db.with(sq).select().from(sq);
```
```sql
with sq as (select "id", "name", "age" from "users" where "id" = 42)
select "id", "name", "age" from sq;
```
</Section>

`with` 내부에 `insert`, `update` 및 `delete` 문을 제공할 수도 있습니다

<Section>
```typescript copy
const sq = db.$with('sq').as(
    db.insert(users).values({ name: 'John' }).returning(),
);

const result = await db.with(sq).select().from(sq);
```
```sql
with "sq" as (insert into "users" ("id", "name") values (default, 'John') returning "id", "name")
select "id", "name" from "sq"
```
</Section>

<Section>
```typescript copy
const sq = db.$with('sq').as(
    db.update(users).set({ age: 25 }).where(eq(users.name, 'John')).returning(),
);
const result = await db.with(sq).select().from(sq);
```
```sql
with "sq" as (update "users" set "age" = 25 where "users"."name" = 'John' returning "id", "name", "age")
select "id", "name", "age" from "sq"
```
</Section>

<Section>
```typescript copy
const sq = db.$with('sq').as(
  db.delete(users).where(eq(users.name, 'John')).returning(),
);

const result = await db.with(sq).select().from(sq);
```
```sql
with "sq" as (delete from "users" where "users"."name" = $1 returning "id", "name", "age")
select "id", "name", "age" from "sq"
```
</Section>

CTE에서 임의의 SQL 값을 필드로 선택하고 다른 CTE나 메인 쿼리에서 참조하려면 별칭을 추가해야 합니다:
```typescript copy

const sq = db.$with('sq').as(db.select({
  name: sql<string>`upper(${users.name})`.as('name'),
})
.from(users));

const result = await db.with(sq).select({ name: sq.name }).from(sq);
```
별칭을 제공하지 않으면 필드 타입이 `DrizzleTypeError`가 되어 다른 쿼리에서 참조할 수 없습니다. 타입 오류를 무시하고 필드를 사용하려고 하면 런타임 오류가 발생합니다. 별칭 없이는 해당 필드를 참조할 방법이 없기 때문입니다.

### 서브쿼리에서 조회
SQL처럼 서브쿼리 API를 사용하여 다른 쿼리에 쿼리를 포함할 수 있습니다:
<Section>
```typescript copy
const sq = db.select().from(users).where(eq(users.id, 42)).as('sq');
const result = await db.select().from(sq);
```
```sql
select "id", "name", "age" from (select "id", "name", "age" from "users" where "id" = 42) "sq";
```
</Section>

서브쿼리는 테이블을 사용할 수 있는 모든 곳에서 사용할 수 있습니다. 예를 들어 조인에서:
<Section>
```typescript copy
const sq = db.select().from(users).where(eq(users.id, 42)).as('sq');
const result = await db.select().from(users).leftJoin(sq, eq(users.id, sq.id));
```
```sql
select "users"."id", "users"."name", "users"."age", "sq"."id", "sq"."name", "sq"."age" from "users"
  left join (select "id", "name", "age" from "users" where "id" = 42) "sq"
    on "users"."id" = "sq"."id";
```
</Section>

## ---

### 집계
Drizzle을 사용하면 원시 SQL에서 하는 것처럼 `.groupBy()` 및 `.having()`을 사용하여 그룹화 및 필터링을 통해 `sum`, `count`, `avg` 등의 함수를 사용한 집계를 수행할 수 있습니다:

<Section>
```typescript
import { gt } from 'drizzle-orm';

await db.select({
  age: users.age,
  count: sql<number>`cast(count(${users.id}) as int)`,
})
  .from(users)
  .groupBy(users.age);

await db.select({
  age: users.age,
  count: sql<number>`cast(count(${users.id}) as int)`,
})
  .from(users)
  .groupBy(users.age)
  .having(({ count }) => gt(count, 1));
```
```sql
select "age", cast(count("id") as int)
  from "users"
  group by "age";

select "age", cast(count("id") as int)
  from "users"
  group by "age"
  having cast(count("id") as int) > 1;
```
</Section>

<Callout type="info">
`cast(... as int)`는 `count()`가 PostgreSQL에서 `bigint`를, MySQL에서 `decimal`을 반환하기 때문에 필요합니다. 이들은 숫자 대신 문자열 값으로 처리됩니다. 또는 런타임에 값을 숫자로 캐스트하려면 [`.mapWith(Number)`](/docs/sql#sqlmapwith)를 사용할 수 있습니다.

count 집계가 필요한 경우 [`$count`](/docs/select#count) API 사용을 권장합니다
</Callout>

### 집계 헬퍼

Drizzle에는 래핑된 `sql` 함수 세트가 있으므로 앱의 일반적인 경우에 `sql` 템플릿을 작성할 필요가 없습니다

<Callout type="info">
 집계 함수는 SELECT 문의 GROUP BY 절과 함께 자주 사용됩니다. 따라서 하나의 쿼리에서 집계 함수와 다른 컬럼을 사용하여 선택하는 경우 `.groupBy` 절을 사용해야 합니다
</Callout>


**count**

`expression`의 값 개수를 반환합니다.
<Section>
```ts
import { count } from 'drizzle-orm'

await db.select({ value: count() }).from(users);
await db.select({ value: count(users.id) }).from(users);
```
```sql
select count("*") from "users";
select count("id") from "users";
```
```ts
// It's equivalent to writing
await db.select({
  value: sql`count('*'))`.mapWith(Number)
}).from(users);

await db.select({
  value: sql`count(${users.id})`.mapWith(Number)
}).from(users);
```
</Section>

**countDistinct**

`expression`에서 중복되지 않은 값의 개수를 반환합니다.
<Section>
```ts
import { countDistinct } from 'drizzle-orm'

await db.select({ value: countDistinct(users.id) }).from(users);
```
```sql
select count(distinct "id") from "users";
```
```ts
// It's equivalent to writing
await db.select({
  value: sql`count(${users.id})`.mapWith(Number)
}).from(users);
```
</Section>

**avg**

`expression`에서 null이 아닌 모든 값의 평균(산술 평균)을 반환합니다.
<Section>
```ts
import { avg } from 'drizzle-orm'

await db.select({ value: avg(users.id) }).from(users);
```
```sql
select avg("id") from "users";
```
```ts
// It's equivalent to writing
await db.select({
  value: sql`avg(${users.id})`.mapWith(String)
}).from(users);
```
</Section>

**avgDistinct**

`expression`에서 null이 아닌 모든 고유 값의 평균(산술 평균)을 반환합니다.
<Section>
```ts
import { avgDistinct } from 'drizzle-orm'

await db.select({ value: avgDistinct(users.id) }).from(users);
```
```sql
select avg(distinct "id") from "users";
```
```ts
// It's equivalent to writing
await db.select({
  value: sql`avg(distinct ${users.id})`.mapWith(String)
}).from(users);
```
</Section>

**sum**

`expression`에서 null이 아닌 모든 값의 합계를 반환합니다.
<Section>
```ts
import { sum } from 'drizzle-orm'

await db.select({ value: sum(users.id) }).from(users);
```
```sql
select sum("id") from "users";
```
```ts
// It's equivalent to writing
await db.select({
  value: sql`sum(${users.id})`.mapWith(String)
}).from(users);
```
</Section>

**sumDistinct**

`expression`에서 null이 아니고 중복되지 않은 모든 값의 합계를 반환합니다.
<Section>
```ts
import { sumDistinct } from 'drizzle-orm'

await db.select({ value: sumDistinct(users.id) }).from(users);
```
```sql
select sum(distinct "id") from "users";
```
```ts
// It's equivalent to writing
await db.select({
  value: sql`sum(distinct ${users.id})`.mapWith(String)
}).from(users);
```
</Section>

**max**

`expression`의 최대값을 반환합니다.
<Section>
```ts
import { max } from 'drizzle-orm'

await db.select({ value: max(users.id) }).from(users);
```
```sql
select max("id") from "users";
```
```ts
// It's equivalent to writing
await db.select({
  value: sql`max(${expression})`.mapWith(users.id)
}).from(users);
```
</Section>

**min**

`expression`의 최소값을 반환합니다.
<Section>
```ts
import { min } from 'drizzle-orm'

await db.select({ value: min(users.id) }).from(users);
```
```sql
select min("id") from "users";
```
```ts
// It's equivalent to writing
await db.select({
  value: sql`min(${users.id})`.mapWith(users.id)
}).from(users);
```
</Section>

더 고급 예제:

```typescript copy
const orders = sqliteTable('order', {
  id: integer('id').primaryKey(),
  orderDate: integer('order_date', { mode: 'timestamp' }).notNull(),
  requiredDate: integer('required_date', { mode: 'timestamp' }).notNull(),
  shippedDate: integer('shipped_date', { mode: 'timestamp' }),
  shipVia: integer('ship_via').notNull(),
  freight: numeric('freight').notNull(),
  shipName: text('ship_name').notNull(),
  shipCity: text('ship_city').notNull(),
  shipRegion: text('ship_region'),
  shipPostalCode: text('ship_postal_code'),
  shipCountry: text('ship_country').notNull(),
  customerId: text('customer_id').notNull(),
  employeeId: integer('employee_id').notNull(),
});

const details = sqliteTable('order_detail', {
  unitPrice: numeric('unit_price').notNull(),
  quantity: integer('quantity').notNull(),
  discount: numeric('discount').notNull(),
  orderId: integer('order_id').notNull(),
  productId: integer('product_id').notNull(),
});


db
  .select({
    id: orders.id,
    shippedDate: orders.shippedDate,
    shipName: orders.shipName,
    shipCity: orders.shipCity,
    shipCountry: orders.shipCountry,
    productsCount: sql<number>`cast(count(${details.productId}) as int)`,
    quantitySum: sql<number>`sum(${details.quantity})`,
    totalPrice: sql<number>`sum(${details.quantity} * ${details.unitPrice})`,
  })
  .from(orders)
  .leftJoin(details, eq(orders.id, details.orderId))
  .groupBy(orders.id)
  .orderBy(asc(orders.id))
  .all();
```

### $count
<$count />

## ---

### Iterator

<IsSupportedChipGroup chips={{ 'MySQL': true, 'PostgreSQL[WIP]': false, 'SQLite[WIP]': false, 'SingleStore[WIP]': false, 'MSSQL': true, 'CockroachDB[WIP]': false }} />

쿼리에서 매우 많은 양의 행을 반환해야 하고 모두 메모리에 로드하고 싶지 않은 경우 `.iterator()`를 사용하여 쿼리를 비동기 이터레이터로 변환할 수 있습니다:

```ts copy
const iterator = await db.select().from(users).iterator();

for await (const row of iterator) {
  console.log(row);
}
```

준비된 문(prepared statement)에서도 작동합니다:

```ts copy
const query = await db.select().from(users).prepare();
const iterator = await query.iterator();

for await (const row of iterator) {
  console.log(row);
}
```

## ---

### Use Index

`USE INDEX` 힌트는 쿼리를 처리할 때 고려할 인덱스를 옵티마이저에 제안합니다. 옵티마이저가 이러한 인덱스를 강제로 사용하지는 않지만 적합한 경우 우선순위를 지정합니다.

<IsSupportedChipGroup chips={{ 'MySQL': true, 'PostgreSQL': false, 'SQLite': false, 'SingleStore': false, 'MSSQL': false, 'CockroachDB': false }} />

```ts copy
export const users = mysqlTable('users', {
	id: int('id').primaryKey(),
	name: varchar('name', { length: 100 }).notNull(),
}, () => [usersTableNameIndex]);

const usersTableNameIndex = index('users_name_index').on(users.name);

await db.select()
  .from(users, { useIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```

원하는 모든 조인에서 이 옵션을 사용할 수도 있습니다

```ts
await db.select()
  .from(users)
  .leftJoin(posts, eq(posts.userId, users.id), { useIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```

### Ignore Index

`IGNORE INDEX` 힌트는 쿼리에 대해 특정 인덱스를 사용하지 않도록 옵티마이저에 지시합니다. MySQL은 다른 모든 인덱스(있는 경우)를 고려하거나 필요한 경우 전체 테이블 스캔을 수행합니다.

<IsSupportedChipGroup chips={{ 'MySQL': true, 'PostgreSQL': false, 'SQLite': false, 'SingleStore': false, 'MSSQL': false, 'CockroachDB': false }} />

```ts copy
export const users = mysqlTable('users', {
	id: int('id').primaryKey(),
	name: varchar('name', { length: 100 }).notNull(),
}, () => [usersTableNameIndex]);

const usersTableNameIndex = index('users_name_index').on(users.name);

await db.select()
  .from(users, { ignoreIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```

원하는 모든 조인에서 이 옵션을 사용할 수도 있습니다

```ts
await db.select()
  .from(users)
  .leftJoin(posts, eq(posts.userId, users.id), { useIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```


### Force Index

`FORCE INDEX` 힌트는 쿼리에 대해 지정된 인덱스를 강제로 사용하도록 옵티마이저에 지시합니다. 지정된 인덱스를 사용할 수 없는 경우 MySQL은 다른 인덱스로 폴백하지 않습니다. 대신 전체 테이블 스캔을 수행할 수 있습니다.

<IsSupportedChipGroup chips={{ 'MySQL': true, 'PostgreSQL': false, 'SQLite': false, 'SingleStore': false, 'MSSQL': false, 'CockroachDB': false }} />

```ts copy
export const users = mysqlTable('users', {
	id: int('id').primaryKey(),
	name: varchar('name', { length: 100 }).notNull(),
}, () => [usersTableNameIndex]);

const usersTableNameIndex = index('users_name_index').on(users.name);

await db.select()
  .from(users, { forceIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```

원하는 모든 조인에서 이 옵션을 사용할 수도 있습니다

```ts
await db.select()
  .from(users)
  .leftJoin(posts, eq(posts.userId, users.id), { useIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```
