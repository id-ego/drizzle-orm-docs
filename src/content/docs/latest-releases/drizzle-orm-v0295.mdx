---
title: DrizzleORM v0.29.5 릴리스
pubDate: 2024-03-06
description: WITH UPDATE, WITH DELETE, WITH INSERT 추가, 마이그레이션 테이블의 사용자 정의 스키마 및 이름 지정 기능, SQLite 프록시 배치 및 관계형 쿼리 지원 추가.
---

import Section from "@mdx/Section.astro";

## 새로운 기능

### 🎉 WITH UPDATE, WITH DELETE, WITH INSERT

이제 [INSERT](/docs/insert#with-insert-clause), [UPDATE](/docs/update#with-update-clause), [DELETE](/docs/delete#with-delete-clause) 문에서 `WITH` 문을 사용할 수 있습니다

사용 예제

<Section>
```ts copy {6,7}
const averageAmount = db.$with('average_amount').as(
	db.select({ value: sql`avg(${orders.amount})`.as('value') }).from(orders),
);

const result = await db
	.with(averageAmount)
	.delete(orders)
	.where(gt(orders.amount, sql`(select * from ${averageAmount})`))
	.returning({
		id: orders.id,
	});
```

```sql
with "average_amount" as (select avg("amount") as "value" from "orders") 
delete from "orders" 
where "orders"."amount" > (select * from "average_amount") 
returning "id";
```
</Section>

모든 문에 대한 더 많은 예제는 문서를 참고하세요:

- [with insert 문서](/docs/insert#with-insert-clause)
- [with update 문서](/docs/update#with-update-clause)
- [with delete 문서](/docs/delete#with-delete-clause)

### 🎉 마이그레이션 테이블의 사용자 정의 스키마 및 이름 지정 기능

- **마이그레이션을 위한 사용자 정의 테이블**

기본적으로 실행된 마이그레이션에 대한 모든 정보는 데이터베이스의 `__drizzle_migrations` 테이블에 저장되며,
PostgreSQL의 경우 `drizzle` 스키마 내에 저장됩니다. 하지만 이러한 레코드를 저장할 위치를 구성할 수 있습니다.

데이터베이스에 저장되는 마이그레이션을 위한 사용자 정의 테이블 이름을 추가하려면 `migrationsTable` 옵션을 사용해야 합니다

사용 예제

```ts copy {3}
await migrate(db, {
	migrationsFolder: './drizzle',
	migrationsTable: 'my_migrations',
});
```

- **마이그레이션을 위한 사용자 정의 스키마**

> PostgreSQL 데이터베이스에서만 작동합니다

데이터베이스에 저장되는 마이그레이션을 위한 사용자 정의 스키마 이름을 추가하려면 `migrationsSchema` 옵션을 사용해야 합니다

사용 예제

```ts copy {3}
await migrate(db, {
	migrationsFolder: './drizzle',
	migrationsSchema: 'custom',
});
```

### 🎉 SQLite Proxy 배치 및 관계형 쿼리 지원

SQLite 프록시에 대한 자세한 정보는 [문서](/docs/get-started-sqlite#http-proxy)에서 확인할 수 있습니다.

- 이제 SQLite 프록시 드라이버에서 `.query.findFirst` 및 `.query.findMany` 문법을 사용할 수 있습니다

- SQLite Proxy는 다른 모든 드라이버와 동일하게 배치 요청을 지원합니다. 전체 [문서](/docs/batch-api)를 확인하세요

  배치 쿼리를 위한 특정 콜백을 지정하고 프록시 서버에 대한 요청을 처리해야 합니다:

```ts
import { drizzle } from 'drizzle-orm/sqlite-proxy';

type ResponseType = { rows: any[][] | any[] }[];

const db = drizzle(
	async (sql, params, method) => {
		// single query logic
	},
	// new batch callback
	async (
		queries: {
			sql: string;
			params: any[];
			method: 'all' | 'run' | 'get' | 'values';
		}[],
	) => {
		try {
			const result: ResponseType = await axios.post(
				'http://localhost:3000/batch',
				{ queries },
			);

			return result;
		} catch (e: any) {
			console.error('Error from sqlite proxy server:', e);
			throw e;
		}
	},
);
```

그런 다음 모든 쿼리를 프록시하는 `db.batch([])` 메서드를 사용할 수 있습니다

> 배치의 응답은 프록시 서버로 전송된 순서와 동일한 순서로 원시 값의 배열(배열 내 배열)이어야 합니다
