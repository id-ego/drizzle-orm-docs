import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";
import TableWrapper from "@mdx/TableWrapper.astro";

# 버전 관리

`drizzle-seed`는 정적 및 동적 데이터의 출력을 관리하기 위해 버전 관리를 사용합니다. 진정한 결정론을 보장하려면 동일한 `seed` 숫자를 사용할 때 값이 변경되지 않도록 해야 합니다. 정적 데이터 소스나 동적 데이터 생성 로직에 변경이 발생하면 버전이 업데이트되어 이전 버전을 유지하거나 최신 버전을 사용할지 선택할 수 있습니다.

추가 제너레이터와 같은 새로운 기능을 위해 최신 `drizzle-seed` 버전으로 업그레이드하면서도 필요에 따라 이전 버전의 결정론적 출력을 유지할 수 있습니다. 이는 새로운 기능에 접근하면서도 기존의 결정론적 데이터에 의존해야 할 때 특히 유용합니다.

```ts
await seed(db, schema, { version: '2' });
```

## 히스토리
<TableWrapper>
|          api version  |   npm version    |     Changed generators                             |
|  :-------------- | :-------------- | :-------------                         |
|       `v1`            | `0.1.1`          |                                         |
|       `v2 (LTS) `       | `0.2.1`          |`string()`, `interval({ isUnique: true })` |
</TableWrapper>

<Callout collapsed="내부 동작 방식은?">
> 이것은 실제 API 변경이 아니며, `drizzle-seed` 버전 관리를 어떻게 진행할지에 대한 예시일 뿐입니다.

예를 들어, `lastName` 제너레이터가 변경되어 이 제너레이터의 새 버전인 `V2`가 사용 가능해졌습니다.

나중에 `firstName` 제너레이터가 변경되어 이 제너레이터의 `V3` 버전이 사용 가능해졌습니다.

|                  |       `V1`       |      `V2`       |   `V3(latest)`   |
| :--------------: | :--------------: | :-------------: | :--------------: |
| **LastNameGen**  | `LastNameGenV1`  | `LastNameGenV2` |                  |
| **FirstNameGen** | `FirstNameGenV1` |                 | `FirstNameGenV3` |


##### 버전 3의 `firstName` 제너레이터와 버전 2의 `lastName` 제너레이터를 사용
```ts
await seed(db, schema);
```

최신 제너레이터 버전을 바로 사용할 준비가 되지 않았다면, 사용할 최대 버전을 지정할 수 있습니다

##### 버전 1의 `firstName` 제너레이터와 버전 2의 `lastName` 제너레이터를 사용
```ts
await seed(db, schema, { version: '2' });
```

##### 버전 1의 `firstName` 제너레이터와 버전 1의 `lastName` 제너레이터를 사용
```ts
await seed(db, schema, { version: '1' });
```

</Callout>

## 버전 2
#### Unique `interval` 제너레이터 변경

<Callout title='업그레이드 이유'>
이전 버전의 제너레이터는 `1 minute 60 seconds`와 `2 minutes 0 seconds` 같은 간격을 별개의 간격으로 처리할 수 있었습니다.
그러나 `1 minute 60 seconds` 간격이 PostgreSQL 데이터베이스에 삽입되면 자동으로 `2 minutes 0 seconds`로 변환됩니다. 그 결과, `2 minutes 0 seconds` 간격을 나중에 unique 컬럼에 삽입하려고 시도하면 오류가 발생합니다
</Callout>

테이블에 `interval` 타입의 unique 컬럼이 포함되어 있다면 영향을 받습니다:
<Tabs items={['PostgreSQL']}>
<Tab>
```ts
import { drizzle } from "drizzle-orm/node-postgres";
import { pgTable, interval } from "drizzle-orm/pg-core";
import { seed } from "drizzle-seed";

const intervals = pgTable("intervals", {
    interval: interval().unique()
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { intervals });
}

main();
```
</Tab>
</Tabs>

아래 스크립트에 표시된 것처럼 시딩 스크립트에서 unique `interval` 제너레이터를 사용하는 경우 영향을 받습니다:
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
```ts
import { drizzle } from "drizzle-orm/node-postgres";
import { pgTable, interval, char, varchar, text } from "drizzle-orm/pg-core";
import { seed } from "drizzle-seed";

const intervals = pgTable("intervals", {
    interval: interval().unique(),
    interval1: interval(),
    interval2: char({ length: 256 }).unique(),
    interval3: char({ length: 256 }),
    interval4: varchar().unique(),
    interval5: varchar(),
    interval6: text().unique(),
    interval7: text(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { intervals }).refine((f) => ({
    intervals: {
        columns: {
            interval: f.interval({ isUnique: true }),
            interval1: f.interval({ isUnique: true }),
            interval2: f.interval({ isUnique: true }),
            interval3: f.interval({ isUnique: true }),
            interval4: f.interval({ isUnique: true }),
            interval5: f.interval({ isUnique: true }),
            interval6: f.interval({ isUnique: true }),
            interval7: f.interval({ isUnique: true }),
        }
    }
  }));
}

main();
```
</Tab>
<Tab>
```ts
import { binary, char, mysqlTable, text, varbinary, varchar } from 'drizzle-orm/mysql-core';
import { drizzle } from 'drizzle-orm/mysql2';
import { seed } from "drizzle-seed";

const intervals = mysqlTable('intervals', {
	interval1: char({ length: 255 }).unique(),
	interval2: char({ length: 255 }),
	interval3: varchar({ length: 255 }).unique(),
	interval4: varchar({ length: 255 }),
	interval5: binary({ length: 255 }).unique(),
	interval6: binary({ length: 255 }),
	interval7: varbinary({ length: 255 }).unique(),
	interval8: varbinary({ length: 255 }),
	interval9: text(),
});

async function main() {
	const db = drizzle(process.env.DATABASE_URL!);

	await seed(db, { intervals }, { version: '2' }).refine((f) => ({
		intervals: {
			columns: {
				interval: f.interval({ isUnique: true }),
				interval1: f.interval({ isUnique: true }),
				interval2: f.interval({ isUnique: true }),
				interval3: f.interval({ isUnique: true }),
				interval4: f.interval({ isUnique: true }),
				interval5: f.interval({ isUnique: true }),
				interval6: f.interval({ isUnique: true }),
				interval7: f.interval({ isUnique: true }),
				interval8: f.interval({ isUnique: true }),
				interval9: f.interval({ isUnique: true }),
			},
		},
	}));
}

main();

```
</Tab>
<Tab>
```ts
import { blob, sqliteTable, text } from 'drizzle-orm/sqlite-core';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { seed } from 'drizzle-seed';

const intervals = sqliteTable('intervals', {
	interval1: text().unique(),
	interval2: text(),
	interval3: blob().unique(),
	interval4: blob(),
});

async function main() {
	const db = drizzle(process.env.DATABASE_URL!);

	await seed(db, { intervals }).refine((f) => ({
		intervals: {
			columns: {
				interval1: f.interval({ isUnique: true }),
				interval2: f.interval({ isUnique: true }),
				interval3: f.interval({ isUnique: true }),
				interval4: f.interval({ isUnique: true }),
			},
		},
	}));
}

main();

```
</Tab>
</Tabs>

#### `string` 제너레이터 변경: non-unique 및 unique 모두

<Callout title='업그레이드 이유'>
텍스트 컬럼의 길이를 기반으로 unique 문자열을 생성할 수 있는 기능 (예: `varchar(20)`)
</Callout>

테이블에 최대 길이 매개변수가 있는 텍스트 유사 타입의 컬럼이나 텍스트 유사 타입의 unique 컬럼이 포함되어 있다면 영향을 받습니다:
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
```ts
import { drizzle } from "drizzle-orm/node-postgres";
import { pgTable, char, varchar, text } from "drizzle-orm/pg-core";
import { seed } from "drizzle-seed";

const strings = pgTable("strings", {
    string2: char({ length: 256 }).unique(),
    string3: char({ length: 256 }),
    string4: varchar().unique(),
    string5: varchar({ length: 256 }).unique(),
    string6: varchar({ length: 256 }),
    string7: text().unique(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { strings });
}

main();
```
</Tab>
<Tab>
```ts
import { binary, char, mysqlTable, varbinary, varchar } from 'drizzle-orm/mysql-core';
import { drizzle } from 'drizzle-orm/mysql2';
import { seed } from "drizzle-seed";

const strings = mysqlTable('strings', {
	string1: char({ length: 255 }).unique(),
	string2: char({ length: 255 }),
	string3: varchar({ length: 255 }).unique(),
	string4: varchar({ length: 255 }),
	string5: binary({ length: 255 }).unique(),
	string6: binary({ length: 255 }),
	string7: varbinary({ length: 255 }).unique(),
	string8: varbinary({ length: 255 }),
});

async function main() {
	const db = drizzle(process.env.DATABASE_URL!);

	await seed(db, { strings });
}

main();

```
</Tab>
<Tab>
```ts
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { blob, sqliteTable, text } from 'drizzle-orm/sqlite-core';
import { seed } from "drizzle-seed";

const strings = sqliteTable('strings', {
	string1: text().unique(),
	string2: text({ length: 256 }),
	string3: text({ length: 256 }).unique(),
	string4: blob().unique(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { strings });
}

main();
```
</Tab>
</Tabs>

아래 스크립트에 표시된 것처럼 시딩 스크립트에서 `string` 제너레이터를 사용하는 경우 영향을 받습니다:
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
```ts
import { drizzle } from "drizzle-orm/node-postgres";
import { pgTable, char, varchar, text } from "drizzle-orm/pg-core";
import { seed } from "drizzle-seed";

const strings = pgTable("strings", {
    string1: char({ length: 256 }).unique(),
    string2: char({ length: 256 }),
    string3: char({ length: 256 }),
    string4: varchar(),
    string5: varchar().unique(),
    string6: varchar({ length: 256 }).unique(),
    string7: varchar({ length: 256 }),
    string8: varchar({ length: 256 }),
    string9: text().unique(),
    string10: text(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { strings }).refine((f) => ({
    strings: {
        columns: {
            string1: f.string({ isUnique: true }),
            string2: f.string(),
            string3: f.string({ isUnique: true }),
            string4: f.string({ isUnique: true }),
            string5: f.string({ isUnique: true }),
            string6: f.string({ isUnique: true }),
            string7: f.string(),
            string8: f.string({ isUnique: true }),
            string9: f.string({ isUnique: true }),
            string10: f.string({ isUnique: true }),
        }
    }
  }));
}

main();
```
</Tab>
<Tab>
```ts
import { binary, char, mysqlTable, text, varbinary, varchar } from 'drizzle-orm/mysql-core';
import { drizzle } from 'drizzle-orm/mysql2';
import { seed } from "drizzle-seed";

const strings = mysqlTable('strings', {
	string1: char({ length: 255 }).unique(),
	string2: char({ length: 255 }),
	string3: char({ length: 255 }),
	string4: varchar({ length: 255 }).unique(),
	string5: varchar({ length: 255 }),
	string6: varchar({ length: 255 }),
	string7: binary({ length: 255 }).unique(),
	string8: binary({ length: 255 }),
	string9: binary({ length: 255 }),
	string10: varbinary({ length: 255 }).unique(),
	string11: varbinary({ length: 255 }),
	string12: varbinary({ length: 255 }),
	string13: text(),
});

async function main() {
	const db = drizzle(process.env.DATABASE_URL!);

	await seed(db, { strings }).refine((f) => ({
		strings: {
			columns: {
				string1: f.string({ isUnique: true }),
				string2: f.string({ isUnique: true }),
				string3: f.string(),
				string4: f.string({ isUnique: true }),
				string5: f.string({ isUnique: true }),
				string6: f.string(),
				string7: f.string({ isUnique: true }),
				string8: f.string({ isUnique: true }),
				string9: f.string(),
				string10: f.string({ isUnique: true }),
				string11: f.string({ isUnique: true }),
				string12: f.string(),
				string13: f.string({ isUnique: true }),
			},
		},
	}));
}

main();
```
</Tab>
<Tab>
```ts
import { blob, sqliteTable, text } from 'drizzle-orm/sqlite-core';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { seed } from "drizzle-seed";

const strings = sqliteTable("strings", {
    string1: text().unique(),
	string2: text(),
	string3: text({ length: 256 }).unique(),
	string4: text({ length: 256 }),
	string5: text({ length: 256 }),
	string6: blob().unique(),
	string7: blob(),
});

async function main() {
	const db = drizzle(process.env.DATABASE_URL!);

	await seed(db, { strings }).refine((f) => ({
		strings: {
			columns: {
				string1: f.string({ isUnique: true }),
				string2: f.string({ isUnique: true }),
				string3: f.string({ isUnique: true }),
				string4: f.string({ isUnique: true }),
				string5: f.string(),
				string6: f.string({ isUnique: true }),
				string7: f.string({ isUnique: true }),
			},
		},
	}));
}

main();
```
</Tab>
</Tabs>