import Callout from '@mdx/Callout.astro';
import Npm from '@mdx/Npm.astro';

# ìºì‹œ

Drizzleì€ ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  ì¿¼ë¦¬ë¥¼ ë°ì´í„°ë² ì´ìŠ¤ë¡œ ì§ì ‘ ì „ì†¡í•©ë‹ˆë‹¤. ìˆ¨ê²¨ì§„ ë™ì‘ì´ë‚˜ ìë™ ìºì‹± ë˜ëŠ” ë¬´íš¨í™”ê°€ ì—†ì–´ ì‹¤í–‰ë˜ëŠ” ë‚´ìš©ì„ ì •í™•íˆ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìºì‹±ì„ ì›í•œë‹¤ë©´ ëª…ì‹œì ìœ¼ë¡œ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.

ê¸°ë³¸ì ìœ¼ë¡œ Drizzleì€ `explicit` ìºì‹± ì „ëµ(ì¦‰, `global: false`)ì„ ì‚¬ìš©í•˜ë¯€ë¡œ ìš”ì²­í•˜ì§€ ì•ŠëŠ” í•œ ì•„ë¬´ê²ƒë„ ìºì‹œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
ì´ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì˜ˆìƒì¹˜ ëª»í•œ ìƒí™©ì´ë‚˜ ìˆ¨ê²¨ì§„ ì„±ëŠ¥ í•¨ì •ì„ ë°©ì§€í•©ë‹ˆë‹¤.
ë˜ëŠ” `all` ìºì‹±(`global: true`)ì„ í™œì„±í™”í•˜ì—¬ ëª¨ë“  selectê°€ ë¨¼ì € ìºì‹œë¥¼ í™•ì¸í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ë¹ ë¥¸ ì‹œì‘

### Upstash í†µí•©

Drizzleì€ ê¸°ë³¸ì ìœ¼ë¡œ `upstashCache()` í—¬í¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤. í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ Upstash Redisë¥¼ ìë™ êµ¬ì„±ê³¼ í•¨ê»˜ ì‚¬ìš©í•©ë‹ˆë‹¤.

```ts
import { upstashCache } from "drizzle-orm/cache/upstash";
import { drizzle } from "drizzle-orm/...";

const db = drizzle(process.env.DB_URL!, {
  cache: upstashCache(),
});
```

Upstash ìê²© ì¦ëª…ì„ ëª…ì‹œì ìœ¼ë¡œ ì •ì˜í•˜ê±°ë‚˜, ëª¨ë“  ì¿¼ë¦¬ì— ëŒ€í•´ ê¸°ë³¸ì ìœ¼ë¡œ ì „ì—­ ìºì‹±ì„ í™œì„±í™”í•˜ê±°ë‚˜, ì‚¬ìš©ì ì •ì˜ ìºì‹± ì˜µì…˜ì„ ì „ë‹¬í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:

```ts
import { upstashCache } from "drizzle-orm/cache/upstash";
import { drizzle } from "drizzle-orm/...";

const db = drizzle(process.env.DB_URL!, {
  cache: upstashCache({
    // ğŸ‘‡ Redis credentials (optional â€” can also be pulled from env vars)
    url: '<UPSTASH_URL>',
    token: '<UPSTASH_TOKEN>',

    // ğŸ‘‡ Enable caching for all queries by default (optional)
    global: true,

    // ğŸ‘‡ Default cache behavior (optional)
    config: { ex: 60 }
  })
});
```

## ìºì‹œ ì„¤ì • ë ˆí¼ëŸ°ìŠ¤

Drizzleì€ Upstashì— ëŒ€í•´ ë‹¤ìŒ ìºì‹œ ì„¤ì • ì˜µì…˜ì„ ì§€ì›í•©ë‹ˆë‹¤:

```ts
export type CacheConfig = {
  /**
   * Expiration in seconds (positive integer)
   */
  ex?: number;
  /**
   * Set an expiration (TTL or time to live) on one or more fields of a given hash key.
   * Used for HEXPIRE command
   */
  hexOptions?: "NX" | "nx" | "XX" | "xx" | "GT" | "gt" | "LT" | "lt";
};
```

## ìºì‹œ ì‚¬ìš© ì˜ˆì œ

ìºì‹±ì„ êµ¬ì„±í•˜ë©´ ìºì‹œê°€ ë‹¤ìŒê³¼ ê°™ì´ ì‘ë™í•©ë‹ˆë‹¤:

**ì¼€ì´ìŠ¤ 1: `global: false`ë¥¼ ì‚¬ìš©í•˜ëŠ” Drizzle (ê¸°ë³¸ê°’, ì„ íƒì  ìºì‹±)**

```ts
import { upstashCache } from "drizzle-orm/cache/upstash";
import { drizzle } from "drizzle-orm/...";

const db = drizzle(process.env.DB_URL!, {
  // ğŸ‘‡ `global: true` is not passed, false by default
  cache: upstashCache({ url: "", token: "" }),
});
```

ì´ ê²½ìš° ë‹¤ìŒ ì¿¼ë¦¬ëŠ” ìºì‹œì—ì„œ ì½ì§€ ì•ŠìŠµë‹ˆë‹¤

```ts
const res = await db.select().from(users);

// Any mutate operation will still trigger the cache's onMutate handler
// and attempt to invalidate any cached queries that involved the affected tables
await db.insert(users).value({ email: "cacheman@upstash.com" });
```

ì´ ì¿¼ë¦¬ê°€ ìºì‹œì—ì„œ ì½ë„ë¡ í•˜ë ¤ë©´ `.$withCache()`ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤

```ts
const res = await db.select().from(users).$withCache();
```

`.$withCache`ëŠ” ì´ íŠ¹ì • ì¿¼ë¦¬ ì „ëµì„ ê´€ë¦¬í•˜ê³  êµ¬ì„±í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì˜µì…˜ ì„¸íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤

```ts
// rewrite the config for this specific query
.$withCache({ config: {} })

// give this query a custom cache key (instead of hashing query+params under the hood)
.$withCache({ tag: 'custom_key' })

// turn off auto-invalidation for this query
// note: this leads to eventual consistency (explained below)
.$withCache({ autoInvalidate: false })
```

<Callout>
**ìµœì¢… ì¼ê´€ì„± ì˜ˆì œ**

ì´ ì˜ˆì œëŠ” `autoInvalidate: false`ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì„¤ì •í•œ ê²½ìš°ì—ë§Œ ê´€ë ¨ì´ ìˆìŠµë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ `autoInvalidate`ëŠ” í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš° `autoInvalidate`ë¥¼ ë„ê³  ì‹¶ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤:
- ë°ì´í„°ê°€ ìì£¼ ë³€ê²½ë˜ì§€ ì•Šê³  ì•½ê°„ì˜ ì˜¤ë˜ëœ ì •ë³´ê°€ í—ˆìš©ë˜ëŠ” ê²½ìš° (ì˜ˆ: ì œí’ˆ ëª©ë¡, ë¸”ë¡œê·¸ ê²Œì‹œë¬¼)
- ìºì‹œ ë¬´íš¨í™”ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ê²½ìš°

ì´ëŸ¬í•œ ê²½ìš° ì´ ì˜µì…˜ì„ ë„ë©´ ë¶ˆí•„ìš”í•œ ìºì‹œ ë¬´íš¨í™”ë¥¼ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ê¸°ë³¸ê°’ì„ ìœ ì§€í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.

ì˜ˆì œ: 3ì´ˆ TTLë¡œ `usersTable`ì— ëŒ€í•´ ë‹¤ìŒ ì¿¼ë¦¬ë¥¼ ìºì‹œí•œë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤:

``` ts
const recent = await db
  .select().from(usersTable)
  .$withCache({ config: { ex: 3 }, autoInvalidate: false });
```

ëˆ„êµ°ê°€ê°€ `db.insert(usersTable)...`ì„ ì‹¤í–‰í•˜ë©´ ìºì‹œê°€ ì¦‰ì‹œ ë¬´íš¨í™”ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìµœëŒ€ 3ì´ˆ ë™ì•ˆ ì´ì „ ë°ì´í„°ê°€ ê³„ì† í‘œì‹œë˜ë©°, ìµœì¢…ì ìœ¼ë¡œ ì¼ê´€ì„±ì´ í™•ë³´ë©ë‹ˆë‹¤.
</Callout>

**ì¼€ì´ìŠ¤ 2: `global: true` ì˜µì…˜ì„ ì‚¬ìš©í•˜ëŠ” Drizzle**

```ts
import { upstashCache } from "drizzle-orm/cache/upstash";
import { drizzle } from "drizzle-orm/...";

const db = drizzle(process.env.DB_URL!, {
  cache: upstashCache({ url: "", token: "", global: true }),
});
```

ì´ ê²½ìš° ë‹¤ìŒ ì¿¼ë¦¬ëŠ” ìºì‹œì—ì„œ ì½ìŠµë‹ˆë‹¤

```ts
const res = await db.select().from(users);
```

ì´ íŠ¹ì • ì¿¼ë¦¬ì— ëŒ€í•´ ìºì‹œë¥¼ ë¹„í™œì„±í™”í•˜ë ¤ë©´ `.$withCache(false)`ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤

```ts
// disable cache for this query
const res = await db.select().from(users).$withCache(false);
```

`db`ì˜ ìºì‹œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ íŠ¹ì • í…Œì´ë¸”ì´ë‚˜ íƒœê·¸ë¥¼ ë¬´íš¨í™”í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤

```ts
// Invalidate all queries that use the `users` table. You can do this with the Drizzle instance.
await db.$cache.invalidate({ tables: users });
// or
await db.$cache.invalidate({ tables: [users, posts] });

// Invalidate all queries that use the `usersTable`. You can do this by using just the table name.
await db.$cache.invalidate({ tables: "usersTable" });
// or
await db.$cache.invalidate({ tables: ["usersTable", "postsTable"] });

// You can also invalidate custom tags defined in any previously executed select queries.
await db.$cache.invalidate({ tags: "custom_key" });
// or
await db.$cache.invalidate({ tags: ["custom_key", "custom_key1"] });
```

## ì‚¬ìš©ì ì •ì˜ ìºì‹œ

ì´ ì˜ˆì œëŠ” Drizzleì— ì‚¬ìš©ì ì •ì˜ `cache`ë¥¼ ì—°ê²°í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. ìºì‹œì—ì„œ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ê³ , ê²°ê³¼ë¥¼ ìºì‹œì— ë‹¤ì‹œ ì €ì¥í•˜ê³ , ë®¤í…Œì´ì…˜ì´ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ í•­ëª©ì„ ë¬´íš¨í™”í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

ìºì‹œ í™•ì¥ì€ ë‹¤ìŒ ì„¤ì • ì˜µì…˜ ì„¸íŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤
```ts
export type CacheConfig = {
  /** expire time, in seconds */
  ex?: number;
  /** expire time, in milliseconds */
  px?: number;
  /** Unix time (sec) at which the key will expire */
  exat?: number;
  /** Unix time (ms) at which the key will expire */
  pxat?: number;
  /** retain existing TTL when updating a key */
  keepTtl?: boolean;
  /** options for HEXPIRE (hash-field TTL) */
  hexOptions?: 'NX' | 'XX' | 'GT' | 'LT' | 'nx' | 'xx' | 'gt' | 'lt';
};
```

```ts
const db = drizzle(process.env.DB_URL!, { cache: new TestGlobalCache() });
```

```ts
import Keyv from "keyv";

export class TestGlobalCache extends Cache {
  private globalTtl: number = 1000;
  // This object will be used to store which query keys were used
  // for a specific table, so we can later use it for invalidation.
  private usedTablesPerKey: Record<string, string[]> = {};

  constructor(private kv: Keyv = new Keyv()) {
    super();
  }

  // For the strategy, we have two options:
  // - 'explicit': The cache is used only when .$withCache() is added to a query.
  // - 'all': All queries are cached globally.
  // The default behavior is 'explicit'.
  override strategy(): "explicit" | "all" {
    return "all";
  }

  // This function accepts query and parameters that cached into key param,
  // allowing you to retrieve response values for this query from the cache.
  override async get(key: string): Promise<any[] | undefined> {
    const res = (await this.kv.get(key)) ?? undefined;
    return res;
  }

  // This function accepts several options to define how cached data will be stored:
  // - 'key': A hashed query and parameters.
  // - 'response': An array of values returned by Drizzle from the database.
  // - 'tables': An array of tables involved in the select queries. This information is needed for cache invalidation.
  //
  // For example, if a query uses the "users" and "posts" tables, you can store this information. Later, when the app executes
  // any mutation statements on these tables, you can remove the corresponding key from the cache.
  // If you're okay with eventual consistency for your queries, you can skip this option.
  override async put(
    key: string,
    response: any,
    tables: string[],
    config?: CacheConfig,
  ): Promise<void> {
    const ttl = config?.px ?? (config?.ex ? config.ex * 1000 : this.globalTtl);

    await this.kv.set(key, response, ttl);

    for (const table of tables) {
      const keys = this.usedTablesPerKey[table];
      if (keys === undefined) {
        this.usedTablesPerKey[table] = [key];
      } else {
        keys.push(key);
      }
    }
  }

  // This function is called when insert, update, or delete statements are executed.
  // You can either skip this step or invalidate queries that used the affected tables.
  //
  // The function receives an object with two keys:
  // - 'tags': Used for queries labeled with a specific tag, allowing you to invalidate by that tag.
  // - 'tables': The actual tables affected by the insert, update, or delete statements,
  //   helping you track which tables have changed since the last cache update.
  override async onMutate(params: {
    tags: string | string[];
    tables: string | string[] | Table<any> | Table<any>[];
  }): Promise<void> {
    const tagsArray = params.tags
      ? Array.isArray(params.tags)
        ? params.tags
        : [params.tags]
      : [];
    const tablesArray = params.tables
      ? Array.isArray(params.tables)
        ? params.tables
        : [params.tables]
      : [];

    const keysToDelete = new Set<string>();

    for (const table of tablesArray) {
      const tableName = is(table, Table)
        ? getTableName(table)
        : (table as string);
      const keys = this.usedTablesPerKey[tableName] ?? [];
      for (const key of keys) keysToDelete.add(key);
    }

    if (keysToDelete.size > 0 || tagsArray.length > 0) {
      for (const tag of tagsArray) {
        await this.kv.delete(tag);
      }

      for (const key of keysToDelete) {
        await this.kv.delete(key);
        for (const table of tablesArray) {
          const tableName = is(table, Table)
            ? getTableName(table)
            : (table as string);
          this.usedTablesPerKey[tableName] = [];
        }
      }
    }
  }
}
```

## ì œí•œì‚¬í•­

#### `cache` í™•ì¥ì—ì„œ ì²˜ë¦¬ë˜ì§€ ì•ŠëŠ” ì¿¼ë¦¬:

- ë‹¤ìŒê³¼ ê°™ì€ ì›ì‹œ ì¿¼ë¦¬ì™€ í•¨ê»˜ ìºì‹œ ì‚¬ìš©:

```ts
db.execute(sql`select 1`);
```

- `d1` ë° `libsql`ì˜ `batch` ê¸°ëŠ¥ê³¼ í•¨ê»˜ ìºì‹œ ì‚¬ìš©

```ts
db.batch([
    db.insert(users).values(...),
    db.update(users).set(...).where()
])
```

- íŠ¸ëœì­ì…˜ì—ì„œ ìºì‹œ ì‚¬ìš©
```ts
await db.transaction(async (tx) => {
  await tx.update(accounts).set(...).where(...);
  await tx.update...
});
```

#### ì¼ì‹œì ì¸ ì œí•œì‚¬í•­ìœ¼ë¡œ ê³§ ì²˜ë¦¬ë  ì˜ˆì •:

- Drizzle ê´€ê³„í˜• ì¿¼ë¦¬ì™€ í•¨ê»˜ ìºì‹œ ì‚¬ìš©
```ts
await db.query.users.findMany();
```

- `better-sqlite3`, `Durable Objects`, `expo sqlite`ì™€ í•¨ê»˜ ìºì‹œ ì‚¬ìš©
- AWS Data API ë“œë¼ì´ë²„ì™€ í•¨ê»˜ ìºì‹œ ì‚¬ìš©
- ë·°ì™€ í•¨ê»˜ ìºì‹œ ì‚¬ìš©
