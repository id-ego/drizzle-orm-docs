---
title: "drizzle-typebox"
description: "Drizzle ORM 스키마에서 Typebox 스키마를 생성하는 플러그인"
slug: "typebox"
---

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';

# drizzle-typebox

`drizzle-typebox`는 **[Drizzle ORM](https://github.com/drizzle-team/drizzle-orm)** 스키마에서 **[Typebox](https://github.com/sinclairzx81/typebox)** 스키마를 생성할 수 있게 해주는 플러그인입니다.

### 종속성 설치

<Npm>
drizzle-typebox
</Npm>

<Callout type="warning">
이 문서는 `drizzle-typebox@0.2.0` 이상 버전을 위한 것입니다.

Drizzle ORM v0.36.0 이상 및 Typebox v0.34.8 이상도 설치되어 있어야 합니다.
</Callout>

### Select 스키마

데이터베이스에서 조회된 데이터의 형태를 정의합니다 - API 응답을 검증하는 데 사용할 수 있습니다.

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-typebox';
import { Value } from '@sinclair/typebox/value';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userSelectSchema = createSelectSchema(users);

const rows = await db.select({ id: users.id, name: users.name }).from(users).limit(1);
const parsed: { id: number; name: string; age: number } = Value.Parse(userSelectSchema, rows[0]); // 에러: 위 쿼리에서 `age`가 반환되지 않음

const rows = await db.select().from(users).limit(1);
const parsed: { id: number; name: string; age: number } = Value.Parse(userSelectSchema, rows[0]); // 파싱 성공
```

뷰(View)와 열거형(enum)도 지원됩니다.

```ts copy
import { pgEnum } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-typebox';
import { Value } from '@sinclair/typebox/value';

const roles = pgEnum('roles', ['admin', 'basic']);
const rolesSchema = createSelectSchema(roles);
const parsed: 'admin' | 'basic' = Value.Parse(rolesSchema, ...);

const usersView = pgView('users_view').as((qb) => qb.select().from(users).where(gt(users.age, 18)));
const usersViewSchema = createSelectSchema(usersView);
const parsed: { id: number; name: string; age: number } = Value.Parse(usersViewSchema, ...);
```

### Insert 스키마

데이터베이스에 삽입할 데이터의 형태를 정의합니다 - API 요청을 검증하는 데 사용할 수 있습니다.

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createInsertSchema } from 'drizzle-typebox';
import { Value } from '@sinclair/typebox/value';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userInsertSchema = createInsertSchema(users);

const user = { name: 'John' };
const parsed: { name: string, age: number } = Value.Parse(userInsertSchema, user); // 에러: `age`가 정의되지 않음

const user = { name: 'Jane', age: 30 };
const parsed: { name: string, age: number } = Value.Parse(userInsertSchema, user); // 파싱 성공
await db.insert(users).values(parsed);
```

### Update 스키마

데이터베이스에서 업데이트할 데이터의 형태를 정의합니다 - API 요청을 검증하는 데 사용할 수 있습니다.

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createUpdateSchema } from 'drizzle-typebox';
import { Value } from '@sinclair/typebox/value';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userUpdateSchema = createUpdateSchema(users);

const user = { id: 5, name: 'John' };
const parsed: { name?: string | undefined, age?: number | undefined } = Value.Parse(userUpdateSchema, user); // 에러: `id`는 생성된 컬럼이므로 업데이트할 수 없음

const user = { age: 35 };
const parsed: { name?: string | undefined, age?: number | undefined } = Value.Parse(userUpdateSchema, user); // 파싱 성공
await db.update(users).set(parsed).where(eq(users.name, 'Jane'));
```

### 정제(Refinements)

각 스키마 생성 함수는 필드의 스키마를 확장, 수정 또는 완전히 덮어쓰는 데 사용할 수 있는 추가 선택적 매개변수를 받습니다. 콜백 함수를 정의하면 확장 또는 수정되며, Typebox 스키마를 제공하면 덮어씁니다.

```ts copy
import { pgTable, text, integer, json } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-typebox';
import { Type } from '@sinclair/typebox';
import { Value } from '@sinclair/typebox/value';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  bio: text(),
  preferences: json()
});

const userSelectSchema = createSelectSchema(users, {
  name: (schema) => Type.String({ ...schema, maxLength: 20 }), // 스키마 확장
  bio: (schema) => Type.String({ ...schema, maxLength: 1000 }), // nullable/optional이 되기 전에 스키마 확장
  preferences: Type.Object({ theme: Type.String() }) // 필드를 덮어쓰며, null 허용 여부도 포함
});

const parsed: {
  id: number;
  name: string,
  bio?: string | undefined;
  preferences: {
    theme: string;
  };
} = Value.Parse(userSelectSchema, ...);
```

### 팩토리 함수

더 고급 사용 사례의 경우 `createSchemaFactory` 함수를 사용할 수 있습니다.

**사용 사례: 확장된 Typebox 인스턴스 사용하기**

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createSchemaFactory } from 'drizzle-typebox';
import { t } from 'elysia'; // Extended Typebox instance

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const { createInsertSchema } = createSchemaFactory({ typeboxInstance: t });

const userInsertSchema = createInsertSchema(users, {
  // 이제 확장된 인스턴스를 사용할 수 있습니다
  name: (schema) => t.Number({ ...schema }, { error: '`name` must be a string' })
});
```

### 데이터 타입 레퍼런스

```ts
pg.boolean();

mysql.boolean();

sqlite.integer({ mode: 'boolean' });

// 스키마
Type.Boolean();
```

```ts
pg.date({ mode: 'date' });
pg.timestamp({ mode: 'date' });

mysql.date({ mode: 'date' });
mysql.datetime({ mode: 'date' });
mysql.timestamp({ mode: 'date' });

sqlite.integer({ mode: 'timestamp' });
sqlite.integer({ mode: 'timestamp_ms' });

// 스키마
Type.Date();
```

```ts
pg.date({ mode: 'string' });
pg.timestamp({ mode: 'string' });
pg.cidr();
pg.inet();
pg.interval();
pg.macaddr();
pg.macaddr8();
pg.numeric();
pg.text();
pg.sparsevec();
pg.time();

mysql.binary();
mysql.date({ mode: 'string' });
mysql.datetime({ mode: 'string' });
mysql.decimal();
mysql.time();
mysql.timestamp({ mode: 'string' });
mysql.varbinary();

sqlite.numeric();
sqlite.text({ mode: 'text' });

// 스키마
Type.String();
```

```ts
pg.bit({ dimensions: ... });

// 스키마
t.RegExp(/^[01]+$/, { maxLength: dimensions });
```

```ts
pg.uuid();

// 스키마
Type.String({ format: 'uuid' });
```

```ts
pg.char({ length: ... });

mysql.char({ length: ... });

// 스키마
Type.String({ minLength: length, maxLength: length });
```

```ts
pg.varchar({ length: ... });

mysql.varchar({ length: ... });

sqlite.text({ mode: 'text', length: ... });

// 스키마
Type.String({ maxLength: length });
```

```ts
mysql.tinytext();

// 스키마
Type.String({ maxLength: 255 }); // unsigned 8비트 정수 한계
```

```ts
mysql.text();

// 스키마
Type.String({ maxLength: 65_535 }); // unsigned 16비트 정수 한계
```

```ts
mysql.mediumtext();

// 스키마
Type.String({ maxLength: 16_777_215 }); // unsigned 24비트 정수 한계
```

```ts
mysql.longtext();

// 스키마
Type.String({ maxLength: 4_294_967_295 }); // unsigned 32비트 정수 한계
```

```ts
pg.text({ enum: ... });
pg.char({ enum: ... });
pg.varchar({ enum: ... });

mysql.tinytext({ enum: ... });
mysql.mediumtext({ enum: ... });
mysql.text({ enum: ... });
mysql.longtext({ enum: ... });
mysql.char({ enum: ... });
mysql.varchar({ enum: ... });
mysql.mysqlEnum(..., ...);

sqlite.text({ mode: 'text', enum: ... });

// 스키마
Type.Enum(enum);
```

```ts
mysql.tinyint();

// 스키마
Type.Integer({ minimum: -128, maximum: 127 }); // 8비트 정수 하한과 상한
```

```ts
mysql.tinyint({ unsigned: true });

// 스키마
Type.Integer({ minimum: 0, maximum: 255 }); // unsigned 8비트 정수 하한과 상한
```

```ts
pg.smallint();
pg.smallserial();

mysql.smallint();

// 스키마
Type.Integer({ minimum: -32_768, maximum: 32_767 }); // 16비트 정수 하한과 상한
```

```ts
mysql.smallint({ unsigned: true });

// 스키마
Type.Integer({ minimum: 0, maximum: 65_535 }); // unsigned 16비트 정수 하한과 상한
```

```ts
pg.real();

mysql.float();

// 스키마
Type.Number().min(-8_388_608).max(8_388_607); // 24비트 정수 하한과 상한
```

```ts
mysql.mediumint();

// 스키마
Type.Integer({ minimum: -8_388_608, maximum: 8_388_607 }); // 24비트 정수 하한과 상한
```

```ts
mysql.float({ unsigned: true });

// 스키마
Type.Number({ minimum: 0, maximum: 16_777_215 }); // unsigned 24비트 정수 하한과 상한
```

```ts
mysql.mediumint({ unsigned: true });

// 스키마
Type.Integer({ minimum: 0, maximum: 16_777_215 }); // unsigned 24비트 정수 하한과 상한
```

```ts
pg.integer();
pg.serial();

mysql.int();

// 스키마
Type.Integer({ minimum: -2_147_483_648, maximum: 2_147_483_647 }); // 32비트 정수 하한과 상한
```

```ts
mysql.int({ unsigned: true });

// 스키마
Type.Integer({ minimum: 0, maximum: 4_294_967_295 }); // unsigned 32비트 정수 하한과 상한
```

```ts
pg.doublePrecision();

mysql.double();
mysql.real();

sqlite.real();

// 스키마
Type.Number({ minimum: -140_737_488_355_328, maximum: 140_737_488_355_327 }); // 48비트 정수 하한과 상한
```

```ts
mysql.double({ unsigned: true });

// 스키마
Type.Numer({ minimum: 0, maximum: 281_474_976_710_655 }); // unsigned 48비트 정수 하한과 상한
```

```ts
pg.bigint({ mode: 'number' });
pg.bigserial({ mode: 'number' });

mysql.bigint({ mode: 'number' });
mysql.bigserial({ mode: 'number' });

sqlite.integer({ mode: 'number' });

// 스키마
Type.Integer({ minimum: -9_007_199_254_740_991, maximum: 9_007_199_254_740_991 }); // JavaScript 최소 및 최대 안전 정수
```

```ts
mysql.serial();

// 스키마
Type.Integer({ minimum: 0, maximum: 9_007_199_254_740_991 }); // JavaScript 최대 안전 정수
```

```ts
pg.bigint({ mode: 'bigint' });
pg.bigserial({ mode: 'bigint' });

mysql.bigint({ mode: 'bigint' });

sqlite.blob({ mode: 'bigint' });

// 스키마
Type.BigInt({ minimum: -9_223_372_036_854_775_808n, maximum: 9_223_372_036_854_775_807n }); // 64비트 정수 하한과 상한
```

```ts
mysql.bigint({ mode: 'bigint', unsigned: true });

// 스키마
Type.BigInt({ minimum: 0, maximum: 18_446_744_073_709_551_615n }); // unsigned 64비트 정수 하한과 상한
```

```ts
mysql.year();

// 스키마
Type.Integer({ minimum: 1_901, maximum: 2_155 });
```

```ts
pg.geometry({ type: 'point', mode: 'tuple' });
pg.point({ mode: 'tuple' });

// 스키마
Type.Tuple([Type.Number(), Type.Number()]);
```

```ts
pg.geometry({ type: 'point', mode: 'xy' });
pg.point({ mode: 'xy' });

// 스키마
Type.Object({ x: Type.Number(), y: Type.Number() });
```

```ts
pg.halfvec({ dimensions: ... });
pg.vector({ dimensions: ... });

// 스키마
Type.Array(Type.Number(), { minItems: dimensions, maxItems: dimensions });
```

```ts
pg.line({ mode: 'abc' });

// 스키마
Type.Object({ a: Type.Number(), b: Type.Number(), c: Type.Number() });
```

```ts
pg.line({ mode: 'tuple' });

// 스키마
Type.Tuple([Type.Number(), Type.Number(), Type.Number()]);
```

```ts
pg.json();
pg.jsonb();

mysql.json();

sqlite.blob({ mode: 'json' });
sqlite.text({ mode: 'json' });

// 스키마
Type.Recursive((self) => Type.Union([Type.Union([Type.String(), Type.Number(), Type.Boolean(), Type.Null()]), Type.Array(self), Type.Record(Type.String(), self)]));
```

```ts
sqlite.blob({ mode: 'buffer' });

// 스키마
t.Union([t.Union([t.String(), t.Number(), t.Boolean(), t.Null()]), t.Array(t.Any()), t.Record(t.String(), t.Any())]);
```

```ts
pg.dataType().array(...);

// 스키마
Type.Array(baseDataTypeSchema, { minItems: size, maxItems: size });
```
